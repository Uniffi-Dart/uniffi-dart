diff --git a/.github/workflows/tests.yml b/.github/workflows/tests.yml
index 8f79fc4..adcbeab 100644
--- a/.github/workflows/tests.yml
+++ b/.github/workflows/tests.yml
@@ -16,7 +16,7 @@ jobs:
       matrix:
         rust:
           - stable
-          - "1.75"
+          - "1.81"
           - nightly
     steps:
       - name: Checkout sources
@@ -55,7 +55,7 @@ jobs:
       matrix:
         rust:
           - stable
-          - "1.75"
+          - "1.81"
           - nightly
     steps:
       - name: Checkout sources
diff --git a/.gitignore b/.gitignore
index 999671f..ef7e1e3 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,10 +1,6 @@
 /target
 /uniffi-rs
 /Cargo.lock
-experiments/*
-.vscode/*
 .aider*
-.dart_tool/*
-**/.dart_tool/*
 rust-toolchain.toml
 internal_todo.md
\ No newline at end of file
diff --git a/Cargo.toml b/Cargo.toml
index 07efe92..31c147a 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -5,7 +5,7 @@ edition = "2021"
 license = "Apache-2 or MIT"
 homepage = "https://github.com/acterglobal/uniffi-dart"
 description = "Dart Frontend for UniFFI"
-rust-version = "1.70"
+rust-version = "1.81"
 
 [features]
 defaults = []
@@ -39,7 +39,7 @@ uniffi_dart_macro = { path = "./uniffi_dart_macro" }
 uniffi_bindgen = { workspace = true }
 camino = "1"
 serde = "1"
-toml = "0.5"
+toml = "0.5.1"
 genco = "0.17.5"
 proc-macro2 = "1.0.66"
 
@@ -53,7 +53,7 @@ fs_extra = { version = "1.3.0", optional = true }
 camino-tempfile = { version = "1.0.2", optional = true }
 glob = { version = "0.3.1", optional = true }
 lazy_static = "1.5.0"
-stringcase = "0.3.0"
+stringcase = "0.4.0"
 
 [workspace]
 
@@ -73,7 +73,7 @@ exclude = [
 ]
 
 [workspace.dependencies]
-uniffi = { version = "0.27.1" }
-uniffi_bindgen = { version = "0.27.1" }
-uniffi_build = { version = "0.27.1" }
-uniffi_testing = { version = "0.27.1" }
+uniffi = { version = "0.28.0" }
+uniffi_bindgen = { version = "0.28.0" }
+uniffi_build = { version = "0.28.0" }
+uniffi_testing = { version = "0.28.0" }
diff --git a/experiments/.DS_Store b/experiments/.DS_Store
index 6d63c4c..5bad716 100644
Binary files a/experiments/.DS_Store and b/experiments/.DS_Store differ
diff --git a/experiments/callbacks-b341dcefe6788477/.dart_tool/extension_discovery/README.md b/experiments/callbacks-b341dcefe6788477/.dart_tool/extension_discovery/README.md
deleted file mode 100644
index 9dc6757..0000000
--- a/experiments/callbacks-b341dcefe6788477/.dart_tool/extension_discovery/README.md
+++ /dev/null
@@ -1,31 +0,0 @@
-Extension Discovery Cache
-=========================
-
-This folder is used by `package:extension_discovery` to cache lists of
-packages that contains extensions for other packages.
-
-DO NOT USE THIS FOLDER
-----------------------
-
- * Do not read (or rely) the contents of this folder.
- * Do write to this folder.
-
-If you're interested in the lists of extensions stored in this folder use the
-API offered by package `extension_discovery` to get this information.
-
-If this package doesn't work for your use-case, then don't try to read the
-contents of this folder. It may change, and will not remain stable.
-
-Use package `extension_discovery`
----------------------------------
-
-If you want to access information from this folder.
-
-Feel free to delete this folder
--------------------------------
-
-Files in this folder act as a cache, and the cache is discarded if the files
-are older than the modification time of `.dart_tool/package_config.json`.
-
-Hence, it should never be necessary to clear this cache manually, if you find a
-need to do please file a bug.
diff --git a/experiments/callbacks-b341dcefe6788477/.dart_tool/extension_discovery/devtools.json b/experiments/callbacks-b341dcefe6788477/.dart_tool/extension_discovery/devtools.json
deleted file mode 100644
index 5475825..0000000
--- a/experiments/callbacks-b341dcefe6788477/.dart_tool/extension_discovery/devtools.json
+++ /dev/null
@@ -1 +0,0 @@
-{"version":2,"entries":[{"package":"uniffi_test","rootUri":"../","packageUri":"lib/"}]}
\ No newline at end of file
diff --git a/experiments/callbacks-b341dcefe6788477/.dart_tool/extension_discovery/vs_code.json b/experiments/callbacks-b341dcefe6788477/.dart_tool/extension_discovery/vs_code.json
deleted file mode 100644
index 5475825..0000000
--- a/experiments/callbacks-b341dcefe6788477/.dart_tool/extension_discovery/vs_code.json
+++ /dev/null
@@ -1 +0,0 @@
-{"version":2,"entries":[{"package":"uniffi_test","rootUri":"../","packageUri":"lib/"}]}
\ No newline at end of file
diff --git a/experiments/callbacks-b341dcefe6788477/.dart_tool/package_config.json b/experiments/callbacks-b341dcefe6788477/.dart_tool/package_config.json
index ad692ad..d45a444 100644
--- a/experiments/callbacks-b341dcefe6788477/.dart_tool/package_config.json
+++ b/experiments/callbacks-b341dcefe6788477/.dart_tool/package_config.json
@@ -305,10 +305,10 @@
       "name": "uniffi_test",
       "rootUri": "../",
       "packageUri": "lib/",
-      "languageVersion": "3.5"
+      "languageVersion": "2.19"
     }
   ],
-  "generated": "2025-04-29T13:41:22.874359Z",
+  "generated": "2024-12-08T11:21:42.251845Z",
   "generator": "pub",
   "generatorVersion": "3.5.4",
   "flutterRoot": "file:///usr/local/Caskroom/flutter/3.22.2/flutter",
diff --git a/experiments/callbacks-b341dcefe6788477/.dart_tool/test/incremental_kernel.Ly9AZGFydD0yLjE5 b/experiments/callbacks-b341dcefe6788477/.dart_tool/test/incremental_kernel.Ly9AZGFydD0yLjE5
index 9f41e98..c35b888 100644
Binary files a/experiments/callbacks-b341dcefe6788477/.dart_tool/test/incremental_kernel.Ly9AZGFydD0yLjE5 and b/experiments/callbacks-b341dcefe6788477/.dart_tool/test/incremental_kernel.Ly9AZGFydD0yLjE5 differ
diff --git a/experiments/callbacks-b341dcefe6788477/.dart_tool/test/incremental_kernel.Ly9AZGFydD0zLjU= b/experiments/callbacks-b341dcefe6788477/.dart_tool/test/incremental_kernel.Ly9AZGFydD0zLjU=
deleted file mode 100644
index 25760c5..0000000
Binary files a/experiments/callbacks-b341dcefe6788477/.dart_tool/test/incremental_kernel.Ly9AZGFydD0zLjU= and /dev/null differ
diff --git a/experiments/callbacks-b341dcefe6788477/callbacks.dart b/experiments/callbacks-b341dcefe6788477/callbacks.dart
index e606d46..9e919e0 100644
--- a/experiments/callbacks-b341dcefe6788477/callbacks.dart
+++ b/experiments/callbacks-b341dcefe6788477/callbacks.dart
@@ -141,8 +141,8 @@ class UnexpectedExceptionWithReasonComplexException extends ComplexException {
 }
 
 enum SimpleException {
-  badArgument,
-  unexpectedException,
+  BadArgument,
+  UnexpectedException,
 }
 
 class FfiConverterSimpleException {
@@ -150,9 +150,9 @@ class FfiConverterSimpleException {
     final index = buffer.asUint8List().buffer.asByteData().getInt32(0);
     switch (index) {
       case 1:
-        return SimpleException.badArgument;
+        return SimpleException.BadArgument;
       case 2:
-        return SimpleException.unexpectedException;
+        return SimpleException.UnexpectedException;
       default:
         throw UniffiInternalError(UniffiInternalError.unexpectedEnumCase,
             "Unable to determine enum variant");
@@ -202,13 +202,13 @@ class RustGetters {
     bool v,
     bool argumentTwo,
   ) {
-    var loweredCallback =
-        FfiConverterCallbackInterfaceForeignGetters.lower(callback);
-    var loweredV = FfiConverterBool.lower(v);
-    var loweredArgumentTwo = FfiConverterBool.lower(argumentTwo);
     return rustCall((status) => FfiConverterBool.lift(_UniffiLib.instance
-        .uniffi_callbacks_fn_method_rustgetters_get_bool(uniffiClonePointer(),
-            loweredCallback, loweredV, loweredArgumentTwo, status)));
+        .uniffi_callbacks_fn_method_rustgetters_get_bool(
+            uniffiClonePointer(),
+            FfiConverterCallbackInterfaceForeignGetters.lower(callback),
+            FfiConverterBool.lower(v),
+            FfiConverterBool.lower(argumentTwo),
+            status)));
   }
 
   List<int> getList(
@@ -216,14 +216,13 @@ class RustGetters {
     List<int> v,
     bool arg2,
   ) {
-    var self = uniffiClonePointer();
-    var call = FfiConverterCallbackInterfaceForeignGetters.lower(callback);
-    var sequence = FfiConverterSequenceInt32.lower(v);
-    var arguemtn2 = FfiConverterBool.lower(arg2);
-
     return rustCall((status) => FfiConverterSequenceInt32.lift(
         _UniffiLib.instance.uniffi_callbacks_fn_method_rustgetters_get_list(
-            self, call, sequence, arguemtn2, status)));
+            uniffiClonePointer(),
+            FfiConverterCallbackInterfaceForeignGetters.lower(callback),
+            FfiConverterSequenceInt32.lower(v),
+            FfiConverterBool.lower(arg2),
+            status)));
   }
 
   void getNothing(
@@ -246,14 +245,6 @@ class RustGetters {
     String? v,
     bool arg2,
   ) {
-    print('Rust Getters getOption');
-    var self = uniffiClonePointer();
-    var call = FfiConverterCallbackInterfaceForeignGetters.lower(callback);
-    var arguemtn2 = FfiConverterBool.lower(arg2);
-    var tempv = FfiConverterOptionalString.lower(v);
-
-    print(
-        "Passing uniffi_callbacks_fn_method_rustgetters_get_string_optional_callback");
     return rustCall((status) => FfiConverterOptionalString.lift(
         _UniffiLib.instance.uniffi_callbacks_fn_method_rustgetters_get_option(
             uniffiClonePointer(),
@@ -282,8 +273,6 @@ class RustGetters {
     String v,
     bool arg2,
   ) {
-    print(
-        "Passing uniffi_callbacks_fn_method_rustgetters_get_string_optional_callback");
     return rustCall((status) => FfiConverterOptionalString.lift(_UniffiLib
         .instance
         .uniffi_callbacks_fn_method_rustgetters_get_string_optional_callback(
@@ -391,7 +380,7 @@ const int CALL_SUCCESS = 0;
 const int CALL_ERROR = 1;
 const int CALL_UNEXPECTED_ERROR = 2;
 
-final class RustCallStatus extends Struct {
+class RustCallStatus extends Struct {
   @Int8()
   external int code;
 
@@ -438,7 +427,7 @@ abstract class UniffiRustCallStatusErrorHandler {
   Exception lift(RustBuffer errorBuf);
 }
 
-final class RustBuffer extends Struct {
+class RustBuffer extends Struct {
   @Uint64()
   external int capacity;
 
@@ -475,7 +464,7 @@ final class RustBuffer extends Struct {
 
   @override
   String toString() {
-    return "RustBuffer{capacity: $capacity, len: $len, data: $data}";
+    return "RustBuffer{capacity: \$capacity, len: \$len, data: \$data}";
   }
 }
 
@@ -492,7 +481,7 @@ RustBuffer toRustBuffer(Uint8List data) {
   return RustBuffer.fromBytes(bytes.ref);
 }
 
-final class ForeignBytes extends Struct {
+class ForeignBytes extends Struct {
   @Int32()
   external int len;
   external Pointer<Uint8> data;
@@ -607,17 +596,13 @@ class FfiConverterOptionalCallbackInterfaceForeignGetters {
 
 class FfiConverterOptionalString {
   static String? lift(RustBuffer buf) {
-    print("Buffer Read when lifting: $buf");
     return FfiConverterOptionalString.read(buf.asUint8List()).value;
   }
 
   static LiftRetVal<String?> read(Uint8List buf) {
-    var tempbuf = buf;
     if (ByteData.view(buf.buffer, buf.offsetInBytes).getInt8(0) == 0) {
       return LiftRetVal(null, 1);
     }
-    print(
-        "Uint8List.view(buf.buffer, buf.offsetInBytes + 1): ${Uint8List.view(buf.buffer, buf.offsetInBytes + 1)}");
     return FfiConverterString.read(
             Uint8List.view(buf.buffer, buf.offsetInBytes + 1))
         .copyWithOffset(1);
@@ -895,18 +880,13 @@ typedef UniffiCallbackInterfaceForeignGettersMethod0 = Void Function(
 typedef UniffiCallbackInterfaceForeignGettersMethod0Dart = void Function(
     int, int, int, Pointer<Int8>, Pointer<RustCallStatus>);
 
-typedef UniffiCallbackInterfaceForeignGettersMethod1 = Void Function(
-    Uint64, RustBuffer, Int8, Pointer<RustBuffer>, Pointer<RustCallStatus>);
+typedef UniffiCallbackInterfaceForeignGettersMethod1 = Void Function(Uint64,
+    Pointer<RustBuffer>, Int8, Pointer<RustBuffer>, Pointer<RustCallStatus>);
 typedef UniffiCallbackInterfaceForeignGettersMethod1Dart = void Function(
     int, RustBuffer, int, Pointer<RustBuffer>, Pointer<RustCallStatus>);
 
-typedef UniffiCallbackInterfaceForeignGettersMethod2 = Void Function(
-    Uint64, RustBuffer, Bool, Pointer<RustBuffer>, Pointer<RustCallStatus>);
-typedef UniffiCallbackInterfaceForeignGettersMethod2Dart = void Function(
-    int, RustBuffer, bool, Pointer<RustBuffer>, Pointer<RustCallStatus>);
-
 typedef UniffiCallbackInterfaceForeignGettersMethod4 = Void Function(
-    Uint64, RustBuffer, Pointer<Void>, Pointer<RustCallStatus>);
+    Uint64, Pointer<RustBuffer>, Pointer<Void>, Pointer<RustCallStatus>);
 typedef UniffiCallbackInterfaceForeignGettersMethod4Dart = void Function(
     int, RustBuffer, Pointer<Void>, Pointer<RustCallStatus>);
 // Similarly define other methods...
@@ -916,14 +896,14 @@ typedef UniffiCallbackInterfaceForeignGettersMethod4Dart = void Function(
 typedef UniffiCallbackInterfaceForeignGettersFree = Void Function(Uint64);
 typedef UniffiCallbackInterfaceForeignGettersFreeDart = void Function(int);
 
-final class UniffiVTableCallbackInterfaceForeignGetters extends Struct {
+class UniffiVTableCallbackInterfaceForeignGetters extends Struct {
   external Pointer<NativeFunction<UniffiCallbackInterfaceForeignGettersMethod0>>
       getBool;
-  external Pointer<NativeFunction<UniffiCallbackInterfaceForeignGettersMethod2>>
+  external Pointer<NativeFunction<UniffiCallbackInterfaceForeignGettersMethod1>>
       getString;
-  external Pointer<NativeFunction<UniffiCallbackInterfaceForeignGettersMethod2>>
+  external Pointer<NativeFunction<UniffiCallbackInterfaceForeignGettersMethod1>>
       getOption; // same signature as getString but returns RustBuffer
-  external Pointer<NativeFunction<UniffiCallbackInterfaceForeignGettersMethod2>>
+  external Pointer<NativeFunction<UniffiCallbackInterfaceForeignGettersMethod1>>
       getList;
   external Pointer<NativeFunction<UniffiCallbackInterfaceForeignGettersMethod4>>
       getNothing;
@@ -945,44 +925,55 @@ void foreignGettersGetBool(int uniffiHandle, int v, int argumentTwo,
   }
 }
 
-void foreignGettersGetString(int uniffiHandle, RustBuffer vBuffer, bool arg2,
-    Pointer<RustBuffer> outReturn, Pointer<RustCallStatus> callStatus) {
+void foreignGettersGetString(
+    int uniffiHandle,
+    Pointer<RustBuffer> vBuffer,
+    int arg2,
+    Pointer<RustBuffer> outReturn,
+    Pointer<RustCallStatus> callStatus) {
   final status = callStatus.ref;
   try {
     final obj = FfiConverterCallbackInterfaceForeignGetters._handleMap
         .get(uniffiHandle);
     // Lift the arguments
-    final v = FfiConverterString.lift(vBuffer);
-    print(v);
+    final v = FfiConverterString.lift(vBuffer.ref);
+    final argumentTwo = arg2 == 1;
     // Call the Dart method
-    final result = obj.getString(v, arg2);
+    final result = obj.getString(v, argumentTwo);
     // Lower the result into RustBuffer
     outReturn.ref = FfiConverterString.lower(result);
-    status.code = CALL_SUCCESS;
-    print("result: $result");
-    print("outreturn: $outReturn");
   } catch (e) {
     status.code = CALL_UNEXPECTED_ERROR;
     status.errorBuf = FfiConverterString.lower(e.toString());
   }
 }
 
-void foreignGettersGetOption(int uniffiHandle, RustBuffer vBuffer, bool arg2,
-    Pointer<RustBuffer> outReturn, Pointer<RustCallStatus> callStatus) {
+void foreignGettersGetOption(
+    int uniffiHandle,
+    Pointer<RustBuffer> vBuffer,
+    int arg2,
+    Pointer<RustBuffer> outReturn,
+    Pointer<RustCallStatus> callStatus) {
   final status = callStatus.ref;
   try {
     final obj = FfiConverterCallbackInterfaceForeignGetters._handleMap
         .get(uniffiHandle);
-    final v = FfiConverterOptionalString.lift(vBuffer);
-    final argumentTwo = arg2;
+    // Lift the arguments
+    final v = FfiConverterString.lift(vBuffer.ref);
+    final argumentTwo = arg2 == 1;
     // Call the Dart method
     final result = obj.getOption(v, argumentTwo);
     // Lower the result into RustBuffer
     if (result == null) {
+      // Assuming Rust represents `null` as an optional tag
       outReturn.ref = toRustBuffer(Uint8List.fromList([0]));
     } else {
-      final lowered = FfiConverterOptionalString.lower(result);
-      outReturn.ref = toRustBuffer(lowered.asUint8List());
+      final lowered = FfiConverterString.lower(result);
+      // Prepend the optional tag
+      final buffer = Uint8List(1 + lowered.len);
+      buffer[0] = 1;
+      buffer.setAll(1, lowered.asUint8List()); // Make Rust Buffer Interable
+      outReturn.ref = toRustBuffer(buffer);
     }
   } catch (e) {
     status.code = CALL_UNEXPECTED_ERROR;
@@ -990,16 +981,19 @@ void foreignGettersGetOption(int uniffiHandle, RustBuffer vBuffer, bool arg2,
   }
 }
 
-void foreignGettersGetList(int uniffiHandle, RustBuffer vBuffer, bool arg2,
-    Pointer<RustBuffer> outReturn, Pointer<RustCallStatus> callStatus) {
-  print('foreignGettersGetList');
+void foreignGettersGetList(
+    int uniffiHandle,
+    Pointer<RustBuffer> vBuffer,
+    int arg2,
+    Pointer<RustBuffer> outReturn,
+    Pointer<RustCallStatus> callStatus) {
   final status = callStatus.ref;
   try {
     final obj = FfiConverterCallbackInterfaceForeignGetters._handleMap
         .get(uniffiHandle);
     // Lift the arguments
-    final v = FfiConverterSequenceInt32.lift(vBuffer);
-    final argumentTwo = arg2;
+    final v = FfiConverterSequenceInt32.lift(vBuffer.ref);
+    final argumentTwo = arg2 == 1;
     // Call the Dart method
     final result = obj.getList(v, argumentTwo);
     // Lower the result into RustBuffer
@@ -1010,14 +1004,14 @@ void foreignGettersGetList(int uniffiHandle, RustBuffer vBuffer, bool arg2,
   }
 }
 
-void foreignGettersGetNothing(int uniffiHandle, RustBuffer vBuffer,
+void foreignGettersGetNothing(int uniffiHandle, Pointer<RustBuffer> vBuffer,
     Pointer<Void> unused, Pointer<RustCallStatus> callStatus) {
   final status = callStatus.ref;
   try {
     final obj = FfiConverterCallbackInterfaceForeignGetters._handleMap
         .get(uniffiHandle);
     // Lift the argument
-    final v = FfiConverterString.lift(vBuffer);
+    final v = FfiConverterString.lift(vBuffer.ref);
     // Call the Dart method
     obj.getNothing(v);
     // Indicate success
@@ -1041,15 +1035,15 @@ final foreignGettersGetBoolPointer =
         foreignGettersGetBool);
 
 final foreignGettersGetOptionPointer =
-    Pointer.fromFunction<UniffiCallbackInterfaceForeignGettersMethod2>(
+    Pointer.fromFunction<UniffiCallbackInterfaceForeignGettersMethod1>(
         foreignGettersGetOption);
 
 final foreignGettersGetStringPointer =
-    Pointer.fromFunction<UniffiCallbackInterfaceForeignGettersMethod2>(
+    Pointer.fromFunction<UniffiCallbackInterfaceForeignGettersMethod1>(
         foreignGettersGetString);
 
 final foreignGettersGetListPointer =
-    Pointer.fromFunction<UniffiCallbackInterfaceForeignGettersMethod2>(
+    Pointer.fromFunction<UniffiCallbackInterfaceForeignGettersMethod1>(
         foreignGettersGetList);
 
 final foreignGettersGetNothingPointer =
@@ -1067,17 +1061,17 @@ final foreignGettersFreePointer =
         foreignGettersFreeCallback);
 
 // Once implemented, create a static vtable instance and register it:
-late final Pointer<UniffiVTableCallbackInterfaceForeignGetters>
-    foreignGettersVTable;
+late final UniffiVTableCallbackInterfaceForeignGetters foreignGettersVTable;
 
 void initForeignGettersVTable() {
-  foreignGettersVTable = calloc<UniffiVTableCallbackInterfaceForeignGetters>();
-  foreignGettersVTable.ref.getBool = foreignGettersGetBoolPointer;
-  foreignGettersVTable.ref.getString = foreignGettersGetStringPointer;
-  foreignGettersVTable.ref.getOption = foreignGettersGetOptionPointer;
-  foreignGettersVTable.ref.getList = foreignGettersGetListPointer;
-  foreignGettersVTable.ref.getNothing = foreignGettersGetNothingPointer;
-  foreignGettersVTable.ref.uniffiFree = foreignGettersFreePointer;
+  foreignGettersVTable =
+      calloc<UniffiVTableCallbackInterfaceForeignGetters>().ref
+        ..getBool = foreignGettersGetBoolPointer
+        ..getString = foreignGettersGetStringPointer
+        ..getOption = foreignGettersGetOptionPointer
+        ..getList = foreignGettersGetListPointer
+        ..getNothing = foreignGettersGetNothingPointer
+        ..uniffiFree = foreignGettersFreePointer;
 
   rustCall((status) {
     _UniffiLib.instance.uniffi_callbacks_fn_init_callback_vtable_foreigngetters(
@@ -1101,8 +1095,7 @@ typedef UniffiCallbackInterfaceStoredForeignStringifierMethod1Dart = void
 typedef UniffiCallbackInterfaceFree = Void Function(Uint64);
 typedef UniffiCallbackInterfaceFreeDart = void Function(int);
 
-final class UniffiVTableCallbackInterfaceStoredForeignStringifier
-    extends Struct {
+class UniffiVTableCallbackInterfaceStoredForeignStringifier extends Struct {
   external Pointer<
           NativeFunction<
               UniffiCallbackInterfaceStoredForeignStringifierMethod0>>
@@ -1187,19 +1180,15 @@ final storedForeignStringifierFreePointer =
   // Provide a default value in case of error
 );
 
-late final Pointer<UniffiVTableCallbackInterfaceStoredForeignStringifier>
+late final UniffiVTableCallbackInterfaceStoredForeignStringifier
     storedForeignStringifierVTable;
 
 void initStoredForeignStringifierVTable() {
   storedForeignStringifierVTable =
-      calloc<UniffiVTableCallbackInterfaceStoredForeignStringifier>();
-
-  storedForeignStringifierVTable.ref.fromSimpleType =
-      storedForeignStringifierFromSimpleTypePointer;
-  storedForeignStringifierVTable.ref.fromComplexType =
-      storedForeignStringifierFromComplexTypePointer;
-  storedForeignStringifierVTable.ref.uniffiFree =
-      storedForeignStringifierFreePointer;
+      calloc<UniffiVTableCallbackInterfaceStoredForeignStringifier>().ref
+        ..fromSimpleType = storedForeignStringifierFromSimpleTypePointer
+        ..fromComplexType = storedForeignStringifierFromComplexTypePointer
+        ..uniffiFree = storedForeignStringifierFreePointer;
 
   rustCall((status) {
     _UniffiLib.instance
@@ -1467,24 +1456,24 @@ class _UniffiLib {
                       Pointer<Void>, int, Pointer<RustCallStatus>)>(
               "uniffi_callbacks_fn_method_ruststringifier_from_simple_type");
   late final void Function(
-    Pointer<UniffiVTableCallbackInterfaceForeignGetters>,
+    UniffiVTableCallbackInterfaceForeignGetters,
   ) uniffi_callbacks_fn_init_callback_vtable_foreigngetters =
       _dylib.lookupFunction<
           Void Function(
-            Pointer<UniffiVTableCallbackInterfaceForeignGetters>,
+            UniffiVTableCallbackInterfaceForeignGetters,
           ),
           void Function(
-            Pointer<UniffiVTableCallbackInterfaceForeignGetters>,
+            UniffiVTableCallbackInterfaceForeignGetters,
           )>("uniffi_callbacks_fn_init_callback_vtable_foreigngetters");
   late final void Function(
-    Pointer<UniffiVTableCallbackInterfaceStoredForeignStringifier>,
+    UniffiVTableCallbackInterfaceStoredForeignStringifier,
   ) uniffi_callbacks_fn_init_callback_vtable_storedforeignstringifier =
       _dylib.lookupFunction<
               Void Function(
-                Pointer<UniffiVTableCallbackInterfaceStoredForeignStringifier>,
+                UniffiVTableCallbackInterfaceStoredForeignStringifier,
               ),
               void Function(
-                Pointer<UniffiVTableCallbackInterfaceStoredForeignStringifier>,
+                UniffiVTableCallbackInterfaceStoredForeignStringifier,
               )>(
           "uniffi_callbacks_fn_init_callback_vtable_storedforeignstringifier");
   late final RustBuffer Function(int, Pointer<RustCallStatus>)
diff --git a/experiments/callbacks-b341dcefe6788477/libcallbacks-old.dylib b/experiments/callbacks-b341dcefe6788477/libcallbacks-old.dylib
deleted file mode 100755
index d407c31..0000000
Binary files a/experiments/callbacks-b341dcefe6788477/libcallbacks-old.dylib and /dev/null differ
diff --git a/experiments/callbacks-b341dcefe6788477/libcallbacks.dylib b/experiments/callbacks-b341dcefe6788477/libcallbacks.dylib
index 321d3e1..d407c31 100755
Binary files a/experiments/callbacks-b341dcefe6788477/libcallbacks.dylib and b/experiments/callbacks-b341dcefe6788477/libcallbacks.dylib differ
diff --git a/experiments/callbacks-b341dcefe6788477/pubspec.yaml b/experiments/callbacks-b341dcefe6788477/pubspec.yaml
index c6dfa8d..a30d201 100644
--- a/experiments/callbacks-b341dcefe6788477/pubspec.yaml
+++ b/experiments/callbacks-b341dcefe6788477/pubspec.yaml
@@ -4,7 +4,7 @@
     version: 1.0.0
 
     environment:
-      sdk: '>=3.5.0'
+      sdk: '>=2.19.6 <3.0.0'
     dev_dependencies:
       test: ^1.24.3
     dependencies:
diff --git a/experiments/callbacks-b341dcefe6788477/test/callbacks_test.dart b/experiments/callbacks-b341dcefe6788477/test/callbacks_test.dart
index 111fe09..552894c 100644
--- a/experiments/callbacks-b341dcefe6788477/test/callbacks_test.dart
+++ b/experiments/callbacks-b341dcefe6788477/test/callbacks_test.dart
@@ -9,13 +9,13 @@ class DartGetters extends ForeignGetters {
   String getString(String v, bool arg2) {
     if (v == 'BadArgument') {
       // Throw a UniFFI-generated exception type corresponding to BadArgument
-      throw SimpleException.badArgument;
+      throw SimpleException.BadArgument;
     }
     if (v == 'UnexpectedError') {
       // Throw a UniFFI-generated exception type corresponding to UnexpectedError
-      throw SimpleException.unexpectedException;
+      throw SimpleException.UnexpectedException;
     }
-    return arg2 ? v : '1234567890123';
+    return arg2 ? '1234567890123' : v;
   }
 
   @override
@@ -37,10 +37,10 @@ class DartGetters extends ForeignGetters {
   @override
   void getNothing(String v) {
     if (v == 'BadArgument') {
-      throw Exception('BadArgument');
+      throw SimpleException.BadArgument;
     }
     if (v == 'UnexpectedError') {
-      throw Exception('UnexpectedError');
+      throw SimpleException.UnexpectedException;
     }
   }
 }
@@ -67,66 +67,58 @@ void main() {
     final flag = true;
     for (final v in [true, false]) {
       final expected = callback.getBool(v, flag);
-      final observed = rustGetters.getBool(callback, v, flag);
+      final observed =  rustGetters.getBool(callback, v, flag);
+      print(observed);  
       expect(observed, equals(expected));
     }
   });
 
-  test('roundtrip getList through callback', () {
-    final flag = true;
-    for (final v in [
-      [1, 2],
-      [0, 1]
-    ]) {
-      final expected = callback.getList(v, flag);
-      final observed = rustGetters.getList(callback, v, flag);
-      expect(observed, equals(expected));
-    }
-  });
+  // test('roundtrip getList through callback', () {
+  //   final flag = true;
+  //   for (final v in [
+  //     [1, 2],
+  //     [0, 1]
+  //   ]) {
+  //     final expected = callback.getList(v, flag);
+  //     final observed = rustGetters.getList(callback, v, flag);
+  //     expect(observed, equals(expected));
+  //   }
+  // });
 
-  test('roundtrip getString through callback', () {
-    final flag = true;
-    for (final v in ["Hello", "world"]) {
-      final expected = callback.getString(v, flag);
-      final observed = rustGetters.getString(callback, v, flag);
-      expect(observed, equals(expected));
-    }
-  });
+  // test('roundtrip getString through callback', () {
+  //   final flag = true;
+  //   for (final v in ["Hello", "world"]) {
+  //     final expected = callback.getString(v, flag);
+  //     final observed = rustGetters.getString(callback, v, flag);
+  //     expect(observed, equals(expected));
+  //   }
+  // });
 
-  test('roundtrip getOption through callback', () {
-    final flag = true;
-    for (final v in ["Some"]) {
-      final expected = callback.getOption(v, flag);
-      final observed = rustGetters.getOption(callback, v, flag);
-      expect(observed, equals(expected));
-    }
-  });
+  // test('roundtrip getOption through callback', () {
+  //   final flag = true;
+  //   for (final v in ["Some", null]) {
+  //     final expected = callback.getOption(v, flag);
+  //     final observed = rustGetters.getOption(callback, v, flag);
+  //     expect(observed, equals(expected));
+  //   }
+  // });
 
-  test('getStringOptionalCallback works', () {
-    expect(
-        rustGetters.getStringOptionalCallback(callback, "1234567890123", false),
-        equals("1234567890123"));
-    // Passing null as the callback
-    expect(rustGetters.getStringOptionalCallback(null, "1234567890123", false),
-        isNull);
-  });
+  // test('getStringOptionalCallback works', () {
+  //   expect(rustGetters.getStringOptionalCallback(callback, "TestString", false),
+  //       equals("TestString"));
+  //   // Passing null as the callback
+  //   expect(rustGetters.getStringOptionalCallback(null, "TestString", false),
+  //       isNull);
+  // });
 
-  test('getNothing should not throw with normal argument', () {
-    // Should not throw
-    rustGetters.getNothing(callback, "1234567890123");
-  });
+  // test('getNothing should not throw with normal argument', () {
+  //   // Should not throw
+  //   rustGetters.getNothing(callback, "TestString");
+  // });
 
-  test('getNothing should throw and exception', () {
-    // Should not throw
-    final v = rustGetters.getNothing(callback, "BadArgument");
-    //print(v);
-    // expect(() => rustGetters.getNothing(callback, "BadArgument"),
-    //     throwsA(isA<SimpleException>()));
-  });
   // test('getString throws SimpleException.BadArgument', () {
-  //   final v = rustGetters.getString(callback, "BadArgument", true);
-  //   print(v);
-  //   //expect(v, throwsA(isA<Exception>()));
+  //   expect(() => rustGetters.getString(callback, "BadArgument", false),
+  //       throwsA(isA<Exception>()));
   // });
 
   // test('getString throws SimpleException.UnexpectedException', () {
@@ -152,15 +144,13 @@ void main() {
   // });
 
   // test('getNothing throws SimpleException.BadArgument', () {
-  //   rustGetters.getNothing(callback, "BadArgument");
-  //   // expect(() => rustGetters.getNothing(callback, "BadArgument"),
-  //   //     throwsA(isA<SimpleException>()));
+  //   expect(() => rustGetters.getNothing(callback, "BadArgument"),
+  //       throwsA(predicate((e) => e == SimpleException.BadArgument)));
   // });
 
   // test('getNothing throws SimpleException.UnexpectedException', () {
-  //   rustGetters.getNothing(callback, "UnexpectedError");
-  //   // expect(() => rustGetters.getNothing(callback, "UnexpectedError"),
-  //   //     throwsA(isA<SimpleException>()));
+  //   expect(() => rustGetters.getNothing(callback, "UnexpectedError"),
+  //       throwsA(predicate((e) => e == SimpleException.UnexpectedException)));
   // });
 
   // test('destroy RustGetters', () {
diff --git a/fixtures/callbacks/src/api.udl b/fixtures/callbacks/src/api.udl
index d16e159..62eff75 100644
--- a/fixtures/callbacks/src/api.udl
+++ b/fixtures/callbacks/src/api.udl
@@ -12,6 +12,7 @@ interface ComplexError {
    UnexpectedErrorWithReason(string reason);
 };
 
+
 /// These objects are implemented by the foreign language and passed
 /// to Rust. Rust then calls methods on it when it needs to.
 ///
diff --git a/fixtures/callbacks/src/lib.rs b/fixtures/callbacks/src/lib.rs
index 6f2d1d5..788bf74 100644
--- a/fixtures/callbacks/src/lib.rs
+++ b/fixtures/callbacks/src/lib.rs
@@ -90,9 +90,6 @@ impl RustGetters {
     }
 }
 
-// TODO: Add error cases to test that the error is returned
-
-
 impl Default for RustGetters {
     fn default() -> Self {
         Self::new()
@@ -123,4 +120,4 @@ impl RustStringifier {
     }
 }
 
-uniffi::include_scaffolding!("api");
\ No newline at end of file
+uniffi::include_scaffolding!("api");
diff --git a/fixtures/callbacks/test/callbacks_test.dart b/fixtures/callbacks/test/callbacks_test.dart
index 9d6feb8..ea8e58a 100644
--- a/fixtures/callbacks/test/callbacks_test.dart
+++ b/fixtures/callbacks/test/callbacks_test.dart
@@ -1,5 +1,6 @@
 import 'package:test/test.dart';
-import '../callbacks.dart'; // Adjust import to your generated code and/or callback interfaces.
+import 'dart:ffi';
+import '../callbacks.dart';
 
 class DartGetters extends ForeignGetters {
   @override
@@ -7,38 +8,37 @@ class DartGetters extends ForeignGetters {
 
   @override
   String getString(String v, bool arg2) {
-    if (v == 'BadArgument') {
-      // Throw a UniFFI-generated exception type corresponding to BadArgument
-      throw SimpleException.badArgument;
+    if (v == 'bad-argument') {
+      throw Exception('bad argument');
     }
-    if (v == 'UnexpectedException') {
-      // Throw a UniFFI-generated exception type corresponding to UnexpectedError
-      throw SimpleException.unexpectedError;
+    if (v == 'unexpected-error') {
+      throw Exception('something failed');
     }
-    return arg2 ? v : '1234567890123';
+    return arg2 ? '1234567890123' : v;
   }
 
   @override
   String? getOption(String? v, bool arg2) {
-    if (v == 'BadArgument') {
-      throw ReallyBadArgumentComplexException(20); // Example of a complex error
+    if (v == 'bad-argument') {
+      throw Exception('bad argument');
     }
-    if (v == 'UnexpectedError') {
-      throw UnexpectedExceptionWithReasonComplexException("something failed");
+    if (v == 'unexpected-error') {
+      throw Exception('something failed');
     }
     return arg2 ? v?.toUpperCase() : v;
   }
 
   @override
-  List<int> getList(List<int> v, bool arg2) => arg2 ? v : <int>[];
+  List<int> getList(Pointer<Int32> v, bool arg2) =>
+      arg2 ? List<int>.from(v.asTypedList(0)) : [];
 
   @override
   void getNothing(String v) {
-    if (v == 'BadArgument') {
-      throw SimpleException.badArgument;
+    if (v == 'bad-argument') {
+      throw Exception('bad argument');
     }
-    if (v == 'UnexpectedError') {
-      throw SimpleException.unexpectedError;
+    if (v == 'unexpected-error') {
+      throw Exception('something failed');
     }
   }
 }
@@ -47,131 +47,118 @@ class StoredDartStringifier extends StoredForeignStringifier {
   @override
   String fromSimpleType(int value) => 'kotlin: $value';
 
-  @override
+  // We don't test this, but we're checking that the arg type is included in the minimal list of types used
+  // in the UDL.
+  // If this doesn't compile, then look at TypeResolver.
   String fromComplexType(List<double?>? values) => 'kotlin: $values';
 }
 
-void main() {
-  ensureInitialized();
-  // Initialize all VTables
-  initForeignGettersVTable();
-  initStoredForeignStringifierVTable();
 
+void main() {
+  final api = Api.load();
   final callback = DartGetters();
   final rustGetters = RustGetters();
-  final rustStringifier = RustStringifier(StoredDartStringifier());
-
-  test('roundtrip getBool through callback', () {
-    final flag = true;
-    for (final v in [true, false]) {
-      final expected = callback.getBool(v, flag);
-      final observed = rustGetters.getBool(callback, v, flag);
-      expect(observed, equals(expected));
-    }
-  });
-
-  // TODO: Bring back after we've fully implemented sequences
-  test('roundtrip getList through callback', () {
-    final flag = true;
-    for (final v in [
-      [1, 2],
-      [0, 1]
-    ]) {
-      final expected = callback.getList(v, flag);
-      final observed = rustGetters.getList(callback, v, flag);
-      expect(observed, equals(expected));
-    }
-  });
-
-  test('roundtrip getString through callback', () {
-    final flag = true;
-    for (final v in ["Hello", "world"]) {
-      final expected = callback.getString(v, flag);
-      final observed = rustGetters.getString(callback, v, flag);
-      expect(observed, equals(expected));
-    }
-  });
-
-  test('roundtrip getOption through callback', () {
-    final flag = true;
-    for (final v in ["Some"]) {
-      final expected = callback.getOption(v, flag);
-      final observed = rustGetters.getOption(callback, v, flag);
-      expect(observed, equals(expected));
-    }
-  });
-
-  test('getStringOptionalCallback works', () {
-    expect(
-        rustGetters.getStringOptionalCallback(callback, "1234567890123", false),
-        equals("1234567890123"));
-    // Passing null as the callback
-    expect(rustGetters.getStringOptionalCallback(null, "1234567890123", false),
-        isNull);
-  });
-
-  test('getNothing should not throw with normal argument', () {
-    // Should not throw
-    rustGetters.getNothing(callback, "1234567890123");
-  });
-
-  // test('getString throws SimpleException.BadArgument', () {
-  //   final v = rustGetters.getString(callback, "BadArgument", true);
-  //   expect(v, throwsA(isA<Exception>()));
-  // });
-
-  // test('getString throws SimpleException.UnexpectedException', () {
-  //   expect(() => rustGetters.getString(callback, "UnexpectedError", false),
-  //       throwsA(isA<Exception>));
-  // });
-
-  // test('getOption throws ReallyBadArgumentComplexException', () {
-  //   // We expect ReallyBadArgumentComplexException with code=20
-  //   expect(
-  //       () => rustGetters.getOption(callback, "BadArgument", false),
-  //       throwsA(predicate(
-  //           (e) => e is ReallyBadArgumentComplexException && e.code == 20)));
-  // });
-
-  // test('getOption throws UnexpectedExceptionWithReasonComplexException', () {
-  //   // We expect UnexpectedExceptionWithReasonComplexException with reason matching "something failed"
-  //   expect(
-  //       () => rustGetters.getOption(callback, "UnexpectedError", false),
-  //       throwsA(predicate((e) =>
-  //           e is UnexpectedExceptionWithReasonComplexException &&
-  //           e.reason == Exception("something failed").toString())));
-  // });
-
-  // test('getNothing throws SimpleException.BadArgument', () {
-  //   rustGetters.getNothing(callback, "BadArgument");
-  //   // expect(() => rustGetters.getNothing(callback, "BadArgument"),
-  //   //     throwsA(isA<SimpleException>()));
-  // });
-
-  // test('getNothing throws SimpleException.UnexpectedException', () {
-  //   rustGetters.getNothing(callback, "UnexpectedError");
-  //   // expect(() => rustGetters.getNothing(callback, "UnexpectedError"),
-  //   //     throwsA(isA<SimpleException>()));
-  // });
-
-  // test('destroy RustGetters', () {
-  //   rustGetters.dispose();
-  //   // No assertions; just ensure no errors are thrown.
-  // });
-
-  // test('RustStringifier constructed with callback', () {
-  //   final dartStringifier = StoredDartStringifier();
-  //   final rustStringifier2 = RustStringifier(dartStringifier);
-  //   for (final v in [1, 2]) {
-  //     final expected = dartStringifier.fromSimpleType(v);
-  //     final observed = rustStringifier2.fromSimpleType(v);
-  //     expect(observed, equals(expected));
-  //   }
-  //   rustStringifier2.dispose();
-  // });
-
-  // // Clean up
-  // tearDownAll(() {
-  //   rustStringifier.dispose();
-  // });
+
+  // 1. Testing callback methods
+  final bool flag = true;
+
+  for (final v in [true, false]) {
+    final expected = callback.getBool(v, flag);
+    final observed = rustGetters.getBool(callback, v, flag);
+    assert(expected == observed,
+        "roundtripping through callback: $expected != $observed");
+  }
+
+  for (final v in [
+    [1, 2],
+    [0, 1]
+  ]) {
+    final expected = callback.getList(v, flag);
+    final observed = rustGetters.getList(callback, v, flag);
+    assert(expected == observed,
+        "roundtripping through callback: $expected != $observed");
+  }
+
+  for (final v in ["Hello", "world"]) {
+    final expected = callback.getString(v, flag);
+    final observed = rustGetters.getString(callback, v, flag);
+    assert(expected == observed,
+        "roundtripping through callback: $expected != $observed");
+  }
+
+  for (final v in ["Some", null]) {
+    final expected = callback.getOption(v, !flag);
+    final observed = rustGetters.getOption(callback, v, !flag);
+    assert(expected == observed,
+        "roundtripping through callback: $expected != $observed");
+  }
+
+  // Additional tests
+  assert(rustGetters.getStringOptionalCallback(callback, "TestString", false) ==
+      "TestString");
+  assert(rustGetters.getStringOptionalCallback(nullptr, "TestString", false) ==
+      nullptr);
+
+  // Should not throw
+  rustGetters.getNothing(callback, "TestString");
+
+  // Exception handling
+  try {
+    rustGetters.getString(callback, "bad-argument", true);
+    throw Exception("Expected SimpleException.BadArgument");
+  } on SimpleException.BadArgument {
+    // Expected error
+  }
+
+  try {
+    rustGetters.getString(callback, "unexpected-error", true);
+    throw Exception("Expected SimpleException.UnexpectedException");
+  } on SimpleException.UnexpectedException {
+    // Expected error
+  }
+
+  try {
+    rustGetters.getOption(callback, "bad-argument", true);
+    throw Exception("Expected ComplexException.ReallyBadArgument");
+  } on ComplexException.ReallyBadArgument catch (e) {
+    // Expected error
+    assert(e.code == 20);
+  }
+
+  try {
+    rustGetters.getOption(callback, "unexpected-error", true);
+    throw Exception("Expected ComplexException.UnexpectedErrorWithReason");
+  } on ComplexException.UnexpectedErrorWithReason catch (e) {
+    // Expected error
+    assert(e.reason == Exception("something failed").toString());
+  }
+
+  try {
+    rustGetters.getNothing(callback, "bad-argument");
+    throw Exception("Expected SimpleException.BadArgument");
+  } on SimpleException.BadArgument {
+    // Expected error
+  }
+
+  try {
+    rustGetters.getNothing(callback, "unexpected-error");
+    throw Exception("Expected SimpleException.UnexpectedException");
+  } on SimpleException.UnexpectedException {
+    // Expected error
+  }
+
+  rustGetters.destroy();
+
+  // 2. Pass the callback in as a constructor argument
+  final DartStringifier = StoredDartStringifier();
+  final rustStringifier = RustStringifier(DartStringifier);
+
+  for (final v in [1, 2]) {
+    final expected = DartStringifier.fromSimpleType(v);
+    final observed = rustStringifier.fromSimpleType(v);
+    assert(expected == observed,
+        "callback is sent on construction: $expected != $observed");
+  }
+
+  rustStringifier.destroy();
 }
diff --git a/fixtures/streams_ext/src/lib.rs b/fixtures/streams_ext/src/lib.rs
index 623dbad..7027d89 100644
--- a/fixtures/streams_ext/src/lib.rs
+++ b/fixtures/streams_ext/src/lib.rs
@@ -1,22 +1,8 @@
 use async_stream::stream;
 use futures::stream::{self, Stream, StreamExt};
-use futures::TryStreamExt;
 use std::pin::Pin;
 use tokio::time::{interval, Duration};
 
-// // Define custom error enums
-// #[derive(Debug, thiserror::Error)]
-// pub enum StreamErrorInt {
-//     #[error("An integer error occurred: {0}")]
-//     IntegerError(String),
-// }
-
-// #[derive(Debug, thiserror::Error)]
-// pub enum StreamErrorString {
-//     #[error("A string error occurred: {0}")]
-//     StringError(String),
-// }
-
 #[uniffi_dart::export_stream(i32)]
 pub fn simple_stream() -> impl Stream<Item = i32> {
     stream::iter(0..5)
@@ -41,7 +27,6 @@ pub fn fibonacci_stream() -> Pin<Box<dyn Stream<Item = u64> + Send>> {
     })
 }
 
-
 #[uniffi_dart::export_stream(u64)]
 pub fn async_timer_stream() -> Pin<Box<dyn Stream<Item = u64> + Send>> {
     Box::pin(stream! {
@@ -64,65 +49,6 @@ pub fn combined_streams() -> impl Stream<Item = String> + Send {
 
     stream::select(stream1, stream3)
 }
-
-// pub fn error_stream() -> impl Stream<Item = Result<i32,StreamErrorInt> > +Send {
-//     {
-//         let(mut __yield_tx,__yield_rx) = unsafe {
-//             async_stream::__private::yielder::pair()
-//         };
-//         async_stream::__private::AsyncStream::new(__yield_rx,async move {
-//             __yield_tx.send(Ok(1)).await;
-//             __yield_tx.send(Ok(2)).await;
-//             __yield_tx.send(Err(StreamErrorInt::IntegerError("An error occurred".to_string()))).await;
-//             __yield_tx.send(Ok(4)).await;
-//         })
-//     }
-// }
-// #[derive(uniffi::Object)]
-// pub struct ErrorStreamStreamExt {
-//     stream:tokio::sync::Mutex<std::pin::Pin<Box<dyn futures::Stream<Item = Result<i32,StreamErrorInt> > +Send>> > ,
-// }
-// impl ErrorStreamStreamExt {
-//     pub fn new() -> std::sync::Arc<Self>{
-//         std::sync::Arc::new(Self {
-//             stream:tokio::sync::Mutex::new(Box::pin(error_stream())),
-//         })
-//     }
-//     pub async fn next(&self) -> Option<Result<i32,StreamErrorInt> >{
-//         let mut stream = self.stream.lock().await;
-//         stream.as_mut().next().await
-//     }
-
-// }
-
-// #[uniffi_dart::export_stream(Result<i32, StreamErrorInt>)]
-// pub fn error_stream() -> impl Stream<Item = Result<i32, StreamErrorInt>> + Send {
-//     stream! {
-//         yield Ok(1);
-//         yield Ok(2);
-//         yield Err("An error occurred".to_string());
-//         yield Ok(4);
-//     }
-// }
-
-// #[uniffi_dart::export_stream(Result<i32, StreamErrorString>)]
-// pub fn combined_error_streams() -> impl Stream<Item = Result<i32, StreamErrorString>> + Send {
-//     let stream1 = count_stream()
-//         .take(3)
-//         .map(|n| Ok(format!("Count: {}", n)));
-//     let stream3 = fibonacci_stream()
-//         .take(3)
-//         .map(|n| {
-//             if n == 2 {
-//                 Err("Fibonacci error".to_string())
-//             } else {
-//                 Ok(format!("Fibonacci: {}", n))
-//             }
-//         });
-
-//     stream::select(stream1, stream3)
-// }
-
 #[cfg(test)]
 mod tests {
     use super::*;
@@ -143,12 +69,6 @@ mod tests {
         assert_eq!(result, vec![0, 1, 2, 3, 4]);
     }
 
-    // #[tokio::test]
-    // async fn test_alphabet_stream() {
-    //     let result: String = alphabet_stream().collect().await;
-    //     assert_eq!(result, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
-    // }
-
     #[tokio::test]
     async fn test_fibonacci_stream() {
         let result: Vec<u64> = fibonacci_stream().take(10).collect().await;
@@ -238,104 +158,6 @@ mod tests {
         // The next call should return None
         assert_eq!(instance.next().await, None);
     }
-
-    // #[tokio::test]
-    // async fn test_error_stream() {
-    //     let mut stream = error_stream();
-    //     let mut results = Vec::new();
-
-    //     while let Some(item) = stream.next().await {
-    //         match item {
-    //             Ok(value) => results.push(value),
-    //             Err(e) => {
-    //                 results.push(-1); // Using -1 to indicate an error occurred
-    //                 println!("Stream error: {}", e);
-    //             }
-    //         }
-    //     }
-
-    //     assert_eq!(results, vec![1, 2, -1, 4]);
-    // }
-
-    // #[tokio::test]
-    // async fn test_combined_error_streams() {
-    //     let mut stream = combined_error_streams();
-    //     let mut results = Vec::new();
-
-    //     while let Some(item) = stream.next().await {
-    //         match item {
-    //             Ok(value) => results.push(value),
-    //             Err(e) => {
-    //                 results.push("Error".to_string());
-    //                 println!("Combined stream error: {}", e);
-    //             }
-    //         }
-    //     }
-
-    //     assert_eq!(
-    //         results,
-    //         vec![
-    //             "Count: 0".to_string(),
-    //             "Count: 1".to_string(),
-    //             "Count: 2".to_string(),
-    //             "Fibonacci: 0".to_string(),
-    //             "Fibonacci: 1".to_string(),
-    //             "Error".to_string(),
-    //         ]
-    //     );
-    // }
-
-    // #[tokio::test]
-    // async fn test_error_stream_with_timeout() {
-    //     let mut stream = error_stream();
-    //     let result = timeout(Duration::from_secs(1), async {
-    //         let mut collected = Vec::new();
-    //         while let Some(item) = stream.next().await {
-    //             collected.push(item);
-    //         }
-    //         collected
-    //     })
-    //     .await;
-
-    //     match result {
-    //         Ok(items) => {
-    //             assert_eq!(
-    //                 items,
-    //                 vec![
-    //                     Ok(1),
-    //                     Ok(2),
-    //                     Err(StreamErrorInt::IntegerError("An error occurred".to_string())),
-    //                     Ok(4)
-    //                 ]
-    //             );
-    //         }
-    //         Err(_) => panic!("Timeout occurred while collecting error stream"),
-    //     }
-    // }
-
-
-    // #[tokio::test]
-    // async fn test_combined_error_streams_handling() {
-    //     let mut stream = combined_error_streams();
-    //     let mut counts = 0;
-    //     let mut fibs = 0;
-    //     let mut errors = 0;
-
-    //     while let Some(item) = stream.next().await {
-    //         let item: Result<String, StreamErrorString> = item; // Explicit type annotation
-
-    //         match item {
-    //             Ok(ref s) if s.starts_with("Count:") => counts += 1,
-    //             Ok(ref s) if s.starts_with("Fibonacci:") => fibs += 1,
-    //             Err(_) => errors += 1,
-    //             _ => {}
-    //         }
-    //     }
-
-    //     assert_eq!(counts, 3);
-    //     assert_eq!(fibs, 2); // One Fibonacci stream yields an error
-    //     assert_eq!(errors, 1);
-    // }
 }
 
 uniffi::include_scaffolding!("api");
diff --git a/src/bin.rs b/src/bin.rs
index d200638..8b13789 100644
--- a/src/bin.rs
+++ b/src/bin.rs
@@ -1,4 +1 @@
-fn main() {
-    println!("uniffi_bindgen_dart binary");
-    println!("This binary is a placeholder and will be implemented in the future.");
-}
+
diff --git a/src/gen/callback_interface.rs b/src/gen/callback_interface.rs
index fd05063..a51cb43 100644
--- a/src/gen/callback_interface.rs
+++ b/src/gen/callback_interface.rs
@@ -1,21 +1,15 @@
-use genco::prelude::*;
-use uniffi_bindgen::backend::{CodeType, Type};
-use uniffi_bindgen::interface::{AsType, Method, CallbackInterface};
-
-use crate::gen::oracle::{AsCodeType, DartCodeOracle};
-use crate::gen::render::AsRenderable;
 use crate::gen::render::{Renderable, TypeHelperRenderer};
-
+use crate::gen::CodeType;
+use genco::prelude::*;
 
 #[derive(Debug)]
 pub struct CallbackInterfaceCodeType {
     name: String,
-    self_type: Type,
 }
 
 impl CallbackInterfaceCodeType {
-    pub fn new(name: String, self_type: Type) -> Self {
-        Self { name, self_type }
+    pub fn new(name: String) -> Self {
+        Self { name }
     }
 }
 
@@ -34,256 +28,7 @@ impl CodeType for CallbackInterfaceCodeType {
 }
 
 impl Renderable for CallbackInterfaceCodeType {
-    fn render_type_helper(&self, type_helper: &dyn TypeHelperRenderer) -> dart::Tokens {
-        type_helper.include_once_check(&self.canonical_name(), &self.self_type);
-        let callback = type_helper.get_ci().get_callback_interface_definition(&self.name).unwrap();
-        
-        // Generate all necessary components for the callback interface
-        let interface = generate_callback_interface(&self, type_helper);
-        let vtable_interface = generate_callback_vtable_interface(&callback, type_helper);
-        let functions = generate_callback_functions(&callback, type_helper);
-        let vtable_init = generate_callback_interface_vtable_init_funtion(&callback, type_helper);
-        
-        quote! {
-            $interface
-            $vtable_interface
-            $functions
-            $vtable_init
-        }
+    fn render_type_helper(&self, _type_helper: &dyn TypeHelperRenderer) -> dart::Tokens {
+        quote!("Plese start here")
     }
 }
-
-fn generate_callback_interface(
-    callback_codetype: &CallbackInterfaceCodeType,
-    type_helper: &dyn TypeHelperRenderer,
-) -> dart::Tokens {
-    let callback = type_helper.get_ci().get_callback_interface_definition(&callback_codetype.name).unwrap(); // The context here gurantees it always exists, could refactor. 
-    let cls_name = &DartCodeOracle::class_name(callback.name());
-    let ffi_conv_name = &DartCodeOracle::class_name(&callback.as_codetype().ffi_converter_name());
-    let methods = callback.methods();
-    let _vtable_methods = callback.vtable_methods();
-
-
-    let tokens = quote! {
-        // This is the abstract class to be implemented
-        abstract class $cls_name {
-            $(for m in &methods {
-                $(generate_callback_methods_definitions(m, type_helper))
-            })
-        }
-
-        // This is the type helper to convert from FFI to Dart
-        class $ffi_conv_name {
-            static final _handleMap = UniffiHandleMap<$cls_name>();
-
-            static $cls_name lift(int handle) {
-                return _handleMap.get(handle);
-            }
-            
-            static int lower($cls_name value) {
-                return _handleMap.insert(value);
-            }
-        
-            static LiftRetVal<$cls_name> read(Uint8List buf) {
-                final handle = buf.buffer.asByteData(buf.offsetInBytes).getInt64(0);
-                return LiftRetVal(lift(handle), 8);
-            }
-        
-            static int write($cls_name value, Uint8List buf) {
-                final handle = lower(value);
-                buf.buffer.asByteData(buf.offsetInBytes).setInt64(0, handle);
-                return 8;
-            }
-        
-            static int allocationSize($cls_name value) {
-                return 8; // Just a handle (int64).
-            }
-        }
-
-        // We must define callback signatures
-        $(generate_callback_methods_signatures(cls_name, &methods, type_helper))
-    };
-
-    tokens
-}
-
-fn generate_callback_methods_definitions(method: &Method, type_helper: &dyn TypeHelperRenderer) -> dart::Tokens {
-    let method_name = DartCodeOracle::fn_name(&method.name());
-    let dart_args = &method.arguments().iter().map(|arg| {
-        let arg_type = arg.as_renderable().render_type(&arg.as_type(), type_helper);
-        let arg_name = DartCodeOracle::var_name(arg.name());
-
-
-        quote!($arg_type $arg_name)
-    }).into_iter().collect::<Vec<_>>();
-
-    let ret_type = if let Some(ret) = method.return_type() {
-        ret.as_renderable().render_type(ret, type_helper)
-    } else {
-        quote!(void)
-    };
-
-    quote!(
-        $ret_type $method_name($(for a in dart_args => $a,));
-    )
-}
-
-fn generate_callback_methods_signatures(callback_name: &str, methods: &Vec<&Method>, _type_helper: &dyn TypeHelperRenderer) -> dart::Tokens {
-    let mut tokens = dart::Tokens::new();
-    for (method_index, method) in methods.iter().enumerate() {
-        //let method_name = DartCodeOracle::fn_name(method.name());
-
-        let ffi_method_type = format!(
-            "UniffiCallbackInterface{}Method{}",
-            callback_name,
-            method_index
-        );
-
-        let dart_method_type = format!(
-            "UniffiCallbackInterface{}Method{}Dart",
-            callback_name,
-            method_index
-        );
-        
-        let method_return_type = if let Some(ret) = method.return_type() {
-            DartCodeOracle::native_type_label(Some(ret))
-        } else {
-            quote!(Void)
-        };
-
-        tokens.append(quote! {
-            typedef $ffi_method_type = Void Function(
-                Uint64, $(for arg in &method.arguments() => $(DartCodeOracle::native_type_label(Some(&arg.as_type()))),)
-                Pointer<$(&method_return_type)>, Pointer<RustCallStatus>);
-            typedef $dart_method_type = void Function(
-                int, $(for arg in &method.arguments() => $(DartCodeOracle::native_dart_type_label(Some(&arg.as_type()))),)
-                Pointer<$(&method_return_type)>, Pointer<RustCallStatus>);
-        });
-    }
-
-    tokens.append(quote! {
-        typedef UniffiCallbackInterface$(callback_name)Free = Void Function(Uint64);
-        typedef UniffiCallbackInterface$(callback_name)FreeDart = void Function(int);
-    });
-
-    tokens
-}
-
-fn generate_callback_vtable_interface(callback: &CallbackInterface, _type_helper: &dyn TypeHelperRenderer) -> dart::Tokens {
-    let vtable_name = format!("UniffiVTableCallbackInterface{}", callback.name());
-    let methods = callback.methods();
-    let methods_vec: Vec<_> = methods.into_iter().enumerate().collect();
-
-    quote! {
-        final class $vtable_name extends Struct {
-            $(for (index, m) in &methods_vec =>
-                external Pointer<NativeFunction<UniffiCallbackInterface$(callback.name())Method$(format!("{}",index))>> $(DartCodeOracle::fn_name(m.name()));
-            )
-            external Pointer<NativeFunction<UniffiCallbackInterface$(callback.name())Free>> uniffiFree;
-        }
-    }
-}
-
-fn generate_callback_functions(callback: &CallbackInterface, _type_helper: &dyn TypeHelperRenderer) -> dart::Tokens {    
-    let cls_name = &DartCodeOracle::class_name(callback.name());
-    let methods = callback.methods();
-
-    let functions: Vec<dart::Tokens> = methods.iter().enumerate().map(|(index, m)| {
-        let method_name = &format!("{}", &DartCodeOracle::fn_name(m.name()));
-        let ffi_method_type = &format!("UniffiCallbackInterface{}Method{}", callback.name(), index);
-        let _dart_method_type = &format!("UniffiCallbackInterface{}Method{}Dart", callback.name(), index);
-
-        // Get parameter types using the oracle
-        let param_types: Vec<dart::Tokens> = m.arguments().iter().map(|arg| {
-            let arg_name = DartCodeOracle::var_name(arg.name());
-            DartCodeOracle::callback_param_type(&arg.as_type(), &arg_name)
-        }).collect();
-
-        // Get argument lifts using the oracle
-        let arg_lifts: Vec<dart::Tokens> = m.arguments().iter().enumerate().map(|(arg_idx, arg)| {
-            let arg_name = DartCodeOracle::var_name(arg.name());
-            DartCodeOracle::callback_arg_lift_indexed(&arg.as_type(), &arg_name, arg_idx)
-        }).collect();
-
-        // Prepare arg names for the method call using indexes
-        let arg_names: Vec<dart::Tokens> = m.arguments().iter().enumerate().map(|(arg_idx, arg)| {
-            DartCodeOracle::callback_arg_name(&arg.as_type(), arg_idx)
-        }).collect();
-
-        // Handle return value using the oracle
-        let call_dart_method = if let Some(ret) = m.return_type() {
-            DartCodeOracle::callback_return_handling(ret, method_name, arg_names)
-        } else {
-            // Handle void return types
-            DartCodeOracle::callback_void_handling(method_name, arg_names)
-        };
-
-        // Get the appropriate out return type
-        let out_return_type = DartCodeOracle::callback_out_return_type(m.return_type());
-
-        // Generate the function body
-        let callback_method_name = &format!("{}{}", &DartCodeOracle::fn_name(callback.name()), &DartCodeOracle::class_name(m.name()));
-        
-        quote! {
-            void $callback_method_name(int uniffiHandle, $(for param in &param_types => $param,) $out_return_type outReturn, Pointer<RustCallStatus> callStatus) {
-                final status = callStatus.ref;
-                try {
-                    final obj = FfiConverterCallbackInterface$cls_name._handleMap.get(uniffiHandle);
-                    $(arg_lifts)
-                    $call_dart_method
-                } catch (e) {
-                    status.code = CALL_UNEXPECTED_ERROR;
-                    status.errorBuf = FfiConverterString.lower(e.toString());
-                }
-            }
-
-            final Pointer<NativeFunction<$ffi_method_type>> $(callback_method_name)Pointer =
-                Pointer.fromFunction<$ffi_method_type>($callback_method_name);
-        }
-    }).collect();
-
-    // Free callback
-    let free_callback_fn = &format!("{}FreeCallback", DartCodeOracle::fn_name(callback.name()));
-    let free_callback_pointer = &format!("{}FreePointer", DartCodeOracle::fn_name(callback.name()));
-    let free_callback_type = &format!("UniffiCallbackInterface{}Free", callback.name());
-    
-    quote! {
-        $(functions)
-
-        void $free_callback_fn(int handle) {
-            try {
-                FfiConverterCallbackInterface$cls_name._handleMap.remove(handle);
-            } catch (e) {
-                // Optionally log error, but do not return anything.
-            }
-        }
-
-        final Pointer<NativeFunction<$free_callback_type>> $free_callback_pointer =
-            Pointer.fromFunction<$free_callback_type>($free_callback_fn);
-    }
-}
-
-fn generate_callback_interface_vtable_init_funtion(callback: &CallbackInterface, _type_helper: &dyn TypeHelperRenderer) -> dart::Tokens {
-    let vtable_name = &format!("UniffiVTableCallbackInterface{}", callback.name());
-    let vtable_static_instance_name = format!("{}{}", DartCodeOracle::fn_name(callback.name()), "VTable");
-    let init_fn_name = &format!("init{}VTable", callback.name());
-
-    quote! {
-        late final Pointer<$vtable_name> $(&vtable_static_instance_name);
-
-        void $init_fn_name() {
-            $(&vtable_static_instance_name) = calloc<$vtable_name>();
-            $(for m in &callback.methods() {
-                $(&vtable_static_instance_name).ref.$(DartCodeOracle::fn_name(m.name())) = $(DartCodeOracle::fn_name(callback.name()))$(DartCodeOracle::class_name(m.name()))Pointer;
-            })
-            $(&vtable_static_instance_name).ref.uniffiFree = $(format!("{}FreePointer", DartCodeOracle::fn_name(callback.name())));
-
-            rustCall((status) {
-                _UniffiLib.instance.uniffi_callbacks_fn_init_callback_vtable_$(callback.name().to_lowercase())(
-                    $(vtable_static_instance_name),
-                );
-                checkCallStatus(NullRustCallStatusErrorHandler(), status);
-            });
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/gen/code_type.rs b/src/gen/code_type.rs
new file mode 100644
index 0000000..73e42b1
--- /dev/null
+++ b/src/gen/code_type.rs
@@ -0,0 +1,51 @@
+use std::fmt::Debug;
+use uniffi_bindgen::backend::Literal;
+
+/// A trait tor the implementation.
+pub trait CodeType: Debug {
+    /// The language specific label used to reference this type. This will be used in
+    /// method signatures and property declarations.
+    fn type_label(&self) -> String;
+
+    /// A representation of this type label that can be used as part of another
+    /// identifier. e.g. `read_foo()`, or `FooInternals`.
+    ///
+    /// This is especially useful when creating specialized objects or methods to deal
+    /// with this type only.
+    fn canonical_name(&self) -> String {
+        self.type_label()
+    }
+
+    fn literal(&self, _literal: &Literal) -> String {
+        unimplemented!("Unimplemented for {}", self.type_label())
+    }
+
+    /// Name of the FfiConverter
+    ///
+    /// This is the object that contains the lower, write, lift, and read methods for this type.
+    fn ffi_converter_name(&self) -> String {
+        format!("FfiConverter{}", self.canonical_name())
+    }
+
+    /// Function to run at startup
+    fn initialization_fn(&self) -> Option<String> {
+        None
+    }
+
+    // The following must create an instance of the converter object
+    fn lower(&self) -> String {
+        format!("{}.lower", self.ffi_converter_name())
+    }
+
+    fn write(&self) -> String {
+        format!("{}.write", self.ffi_converter_name())
+    }
+
+    fn lift(&self) -> String {
+        format!("{}.lift", self.ffi_converter_name())
+    }
+
+    fn read(&self) -> String {
+        format!("{}.read", self.ffi_converter_name())
+    }
+}
diff --git a/src/gen/compounds.rs b/src/gen/compounds.rs
index 0d85897..e671505 100644
--- a/src/gen/compounds.rs
+++ b/src/gen/compounds.rs
@@ -1,7 +1,7 @@
+use crate::gen::CodeType;
 use genco::lang::dart;
 use genco::prelude::*;
 use paste::paste;
-use uniffi_bindgen::backend::CodeType;
 use uniffi_bindgen::interface::Type;
 
 use super::oracle::{AsCodeType, DartCodeOracle};
diff --git a/src/gen/enums.rs b/src/gen/enums.rs
index 0fcc1d9..6513928 100644
--- a/src/gen/enums.rs
+++ b/src/gen/enums.rs
@@ -1,5 +1,6 @@
+use crate::gen::CodeType;
 use genco::prelude::*;
-use uniffi_bindgen::backend::{CodeType, Literal};
+use uniffi_bindgen::backend::Literal;
 use uniffi_bindgen::interface::{AsType, Enum};
 
 use super::oracle::{AsCodeType, DartCodeOracle};
@@ -36,10 +37,6 @@ impl CodeType for EnumCodeType {
             unreachable!();
         }
     }
-
-    fn ffi_converter_name(&self) -> String {
-        format!("FfiConverter{}", &DartCodeOracle::class_name(&self.canonical_name()))
-    }
 }
 
 impl Renderable for EnumCodeType {
@@ -56,30 +53,29 @@ impl Renderable for EnumCodeType {
 
 pub fn generate_enum(obj: &Enum, type_helper: &dyn TypeHelperRenderer) -> dart::Tokens {
     let cls_name = &obj.as_codetype().canonical_name();
-    let dart_cls_name = &DartCodeOracle::class_name(obj.name());
     let ffi_converter_name = &obj.as_codetype().ffi_converter_name();
     if obj.is_flat() {
         quote! {
-            enum $dart_cls_name {
+            enum $cls_name {
                 $(for variant in obj.variants() =>
                 $(DartCodeOracle::enum_variant_name(variant.name())),)
                 ;
             }
 
             class $ffi_converter_name {
-                static $dart_cls_name lift( RustBuffer buffer) {
+                static $cls_name lift( RustBuffer buffer) {
                     final index = buffer.asUint8List().buffer.asByteData().getInt32(0);
                     switch(index) {
                         $(for (index, variant) in obj.variants().iter().enumerate() =>
                         case $(index + 1):
-                            return $dart_cls_name.$(DartCodeOracle::enum_variant_name(variant.name()));
+                            return $cls_name.$(DartCodeOracle::enum_variant_name(variant.name()));
                         )
                         default:
                             throw UniffiInternalError(UniffiInternalError.unexpectedEnumCase, "Unable to determine enum variant");
                     }
                 }
 
-                static RustBuffer lower( $dart_cls_name input) {
+                static RustBuffer lower( $cls_name input) {
                     return toRustBuffer(createUint8ListFromInt(input.index + 1));
                 }
             }
@@ -87,49 +83,26 @@ pub fn generate_enum(obj: &Enum, type_helper: &dyn TypeHelperRenderer) -> dart::
     } else {
         let mut variants = vec![];
 
-        for (index, variant_obj) in obj.variants().iter().enumerate() {
-            for f in variant_obj.fields() {
+        for (index, obj) in obj.variants().iter().enumerate() {
+            for f in obj.fields() {
                 type_helper.include_once_check(&f.as_codetype().canonical_name(), &f.as_type());
             }
-            let variant_dart_cls_name = &format!("{}{}", DartCodeOracle::class_name(variant_obj.name()), dart_cls_name);
-            
-            // Prepare constructor parameters
-            let constructor_params = variant_obj.fields().iter().map(|field| {
-                let param_name = DartCodeOracle::var_name(field.name());
-                let param_type = field.as_type().as_renderable().render_type(&field.as_type(), type_helper);
-                if variant_obj.fields().len() > 1 {
-                    quote!(required this.$param_name)
-                } else {
-                    quote!(this.$param_name)
-                }
-            }).collect::<Vec<_>>();
-            
-            let constructor_param_list = if variant_obj.fields().len() > 1 {
-                quote!({ $( for p in constructor_params => $p, ) })
-            } else {
-                quote!($( for p in constructor_params => $p, ))
-            };
-            
             variants.push(quote!{
-                class $variant_dart_cls_name extends $dart_cls_name {
-                    $(for field in variant_obj.fields() => final $(&field.as_type().as_renderable().render_type(&field.as_type(), type_helper)) $(DartCodeOracle::var_name(field.name()));  )
-                    
-                    // Add the public const constructor
-                    $variant_dart_cls_name($constructor_param_list);
+                class $(DartCodeOracle::class_name(obj.name()))$cls_name extends $cls_name {
+                    $(for field in obj.fields() => final $(&field.as_type().as_renderable().render_type(&field.as_type(), type_helper)) $(DartCodeOracle::var_name(field.name()));  )
 
-                    // Keep the private constructor used by `read`
-                    $variant_dart_cls_name._($(for field in variant_obj.fields() => this.$(DartCodeOracle::var_name(field.name())), ));
+                    $(DartCodeOracle::class_name(obj.name()))$cls_name._($(for field in obj.fields() => this.$(DartCodeOracle::var_name(field.name())), ));
 
-                    static LiftRetVal<$variant_dart_cls_name> read( Uint8List buf) {
+                    static LiftRetVal<$(DartCodeOracle::class_name(obj.name()))$cls_name> read( Uint8List buf) {
                         int new_offset = buf.offsetInBytes;
 
-                        $(for f in variant_obj.fields() =>
+                        $(for f in obj.fields() =>
                             final $(DartCodeOracle::var_name(f.name()))_lifted = $(f.as_type().as_codetype().ffi_converter_name()).read(Uint8List.view(buf.buffer, new_offset));
                             final $(DartCodeOracle::var_name(f.name())) = $(DartCodeOracle::var_name(f.name()))_lifted.value;
                             new_offset += $(DartCodeOracle::var_name(f.name()))_lifted.bytesRead;
                         )
-                        return LiftRetVal($variant_dart_cls_name._(
-                            $(for f in variant_obj.fields() => $(DartCodeOracle::var_name(f.name())),)
+                        return LiftRetVal($(DartCodeOracle::class_name(obj.name()))$cls_name._(
+                            $(for f in obj.fields() => $(DartCodeOracle::var_name(f.name())),)
                         ), new_offset);
                     }
 
@@ -142,7 +115,7 @@ pub fn generate_enum(obj: &Enum, type_helper: &dyn TypeHelperRenderer) -> dart::
 
                     @override
                     int allocationSize() {
-                        return $(for f in variant_obj.fields() => $(f.as_type().as_codetype().ffi_converter_name()).allocationSize($(DartCodeOracle::var_name(f.name()))) + ) 4;
+                        return $(for f in obj.fields() => $(f.as_type().as_codetype().ffi_converter_name()).allocationSize($(DartCodeOracle::var_name(f.name()))) + ) 4;
                     }
 
                     @override
@@ -150,7 +123,7 @@ pub fn generate_enum(obj: &Enum, type_helper: &dyn TypeHelperRenderer) -> dart::
                         buf.buffer.asByteData(buf.offsetInBytes).setInt32(0, $(index + 1)); // write index into first position;
                         int new_offset = buf.offsetInBytes + 4;
 
-                        $(for f in variant_obj.fields() =>
+                        $(for f in obj.fields() =>
                         new_offset += $(f.as_type().as_codetype().ffi_converter_name()).write($(DartCodeOracle::var_name(f.name())), Uint8List.view(buf.buffer, new_offset));
                         )
 
@@ -160,45 +133,39 @@ pub fn generate_enum(obj: &Enum, type_helper: &dyn TypeHelperRenderer) -> dart::
             });
         }
 
-        let implements_exception = if dart_cls_name.ends_with("Exception") {
-            quote!( implements Exception)
-        } else {
-            quote!()
-        };
-
         quote! {
-            abstract class $dart_cls_name $implements_exception {
+            abstract class $cls_name {
                 RustBuffer lower();
                 int allocationSize();
                 int write( Uint8List buf);
             }
 
             class $ffi_converter_name {
-                static $dart_cls_name lift( RustBuffer buffer) {
+                static $cls_name lift( RustBuffer buffer) {
                     return $ffi_converter_name.read(buffer.asUint8List()).value;
                 }
 
-                static LiftRetVal<$dart_cls_name> read( Uint8List buf) {
+                static LiftRetVal<$cls_name> read( Uint8List buf) {
                     final index = buf.buffer.asByteData(buf.offsetInBytes).getInt32(0);
                     final subview = Uint8List.view(buf.buffer, buf.offsetInBytes + 4);
                     switch(index) {
                         $(for (index, variant) in obj.variants().iter().enumerate() =>
                         case $(index + 1):
-                            return $(format!("{}{}", DartCodeOracle::class_name(variant.name()), dart_cls_name)).read(subview);
+                            return $(variant.name())$cls_name.read(subview);
                         )
                         default:  throw UniffiInternalError(UniffiInternalError.unexpectedEnumCase, "Unable to determine enum variant");
                     }
                 }
 
-                static RustBuffer lower( $dart_cls_name value) {
+                static RustBuffer lower( $cls_name value) {
                     return value.lower();
                 }
 
-                static int allocationSize($dart_cls_name value) {
+                static int allocationSize($cls_name value) {
                     return value.allocationSize();
                 }
 
-                static int write( $dart_cls_name value, Uint8List buf) {
+                static int write( $cls_name value, Uint8List buf) {
                     return value.write(buf);
                 }
             }
diff --git a/src/gen/mod.rs b/src/gen/mod.rs
index 11cf2c8..c57efbe 100644
--- a/src/gen/mod.rs
+++ b/src/gen/mod.rs
@@ -1,5 +1,6 @@
 use std::collections::HashMap;
 use std::collections::HashSet;
+use std::io::Read;
 
 use anyhow::Result;
 use camino::Utf8Path;
@@ -7,13 +8,16 @@ use camino::Utf8Path;
 use genco::fmt;
 use genco::prelude::*;
 use serde::{Deserialize, Serialize};
+use uniffi_bindgen::BindgenCrateConfigSupplier;
+use uniffi_bindgen::Component;
 // use uniffi_bindgen::MergeWith;
 use self::render::Renderer;
 use self::types::TypeHelpersRenderer;
 use crate::gen::oracle::DartCodeOracle;
-use uniffi_bindgen::{BindingGenerator, BindingsConfig, ComponentInterface};
+use uniffi_bindgen::{BindingGenerator, ComponentInterface};
 
 mod callback_interface;
+mod code_type;
 mod compounds;
 mod enums;
 mod functions;
@@ -25,6 +29,8 @@ mod render;
 pub mod stream;
 mod types;
 
+pub use code_type::CodeType;
+
 #[derive(Debug, Default, Clone, Serialize, Deserialize)]
 pub struct Config {
     package_name: Option<String>,
@@ -61,25 +67,6 @@ impl Config {
     }
 }
 
-impl BindingsConfig for Config {
-    fn update_from_ci(&mut self, ci: &ComponentInterface) {
-        self.package_name = Some(ci.namespace().to_owned());
-    }
-
-    fn update_from_cdylib_name(&mut self, cdylib_name: &str) {
-        self.cdylib_name = Some(cdylib_name.to_string());
-    }
-
-    fn update_from_dependency_configs(&mut self, config_map: HashMap<&str, &Self>) {
-        for (crate_name, config) in config_map {
-            if !self.external_packages.contains_key(crate_name) {
-                self.external_packages
-                    .insert(crate_name.to_string(), config.package_name());
-            }
-        }
-    }
-}
-
 pub struct DartWrapper<'a> {
     config: &'a Config,
     ci: &'a ComponentInterface,
@@ -163,7 +150,7 @@ impl<'a> DartWrapper<'a> {
             library $package_name;
 
             $(type_helper_code) // Imports, Types and Type Helper
-            
+
             $(functions_definitions)
 
             class _UniffiLib {
@@ -220,46 +207,95 @@ impl BindingGenerator for DartBindingGenerator {
 
     fn write_bindings(
         &self,
-        ci: &ComponentInterface,
-        config: &Self::Config,
-        out_dir: &Utf8Path,
-        _try_format_code: bool,
+        settings: &uniffi_bindgen::GenerationSettings,
+        components: &[uniffi_bindgen::Component<Self::Config>],
     ) -> Result<()> {
-        let filename = out_dir.join(format!("{}.dart", config.cdylib_name()));
-        let tokens = DartWrapper::new(ci, config).generate();
-        let file = std::fs::File::create(filename)?;
-
-        let mut w = fmt::IoWriter::new(file);
-
-        let fmt = fmt::Config::from_lang::<Dart>().with_indentation(fmt::Indentation::Space(4));
-        let config = dart::Config::default();
+        for Component { ci, config, .. } in components {
+            let filename = settings
+                .out_dir
+                .join(format!("{}.dart", config.cdylib_name()));
+            let tokens = DartWrapper::new(ci, config).generate();
+            let file = std::fs::File::create(filename)?;
+
+            let mut w = fmt::IoWriter::new(file);
+
+            let mut fmt = fmt::Config::from_lang::<Dart>();
+            if settings.try_format_code {
+                fmt = fmt.with_indentation(fmt::Indentation::Space(2));
+            }
+            let config = dart::Config::default();
 
-        tokens.format_file(&mut w.as_formatter(&fmt), &config)?;
+            tokens.format_file(&mut w.as_formatter(&fmt), &config)?;
+        }
         Ok(())
     }
-    fn check_library_path(
+
+    fn new_config(&self, root_toml: &toml::value::Value) -> Result<Self::Config> {
+        Ok(
+            match root_toml.get("bindings").and_then(|b| b.get("dart")) {
+                Some(v) => v.clone().try_into()?,
+                None => Default::default(),
+            },
+        )
+    }
+
+    fn update_component_configs(
         &self,
-        _library_path: &Utf8Path,
-        _cdylib_name: Option<&str>,
+        settings: &uniffi_bindgen::GenerationSettings,
+        components: &mut Vec<uniffi_bindgen::Component<Self::Config>>,
     ) -> Result<()> {
-        // FIXME: not sure what to check for here...?
+        for c in &mut *components {
+            c.config.cdylib_name.get_or_insert_with(|| {
+                settings
+                    .cdylib
+                    .clone()
+                    .unwrap_or_else(|| format!("uniffi_{}", c.ci.namespace()))
+            });
+        }
         Ok(())
     }
 }
 
+
+pub struct LocalConfigSupplier(String);
+impl BindgenCrateConfigSupplier for LocalConfigSupplier {
+
+    fn get_udl(&self, _crate_name: &str, _udl_name: &str) -> Result<String> {
+        let file = std::fs::File::open(self.0.clone())?;
+        let mut reader = std::io::BufReader::new(file);
+        let mut content = String::new();
+        reader.read_to_string(&mut content)?;
+        return Ok(content);
+    }
+}
+
 pub fn generate_dart_bindings(
     udl_file: &Utf8Path,
     config_file_override: Option<&Utf8Path>,
     out_dir_override: Option<&Utf8Path>,
-    library_file: Option<&Utf8Path>,
-) -> Result<()> {
-    uniffi_bindgen::generate_external_bindings(
-        &DartBindingGenerator {},
+    library_file: &Utf8Path,
+    library_mode: bool,
+) -> anyhow::Result<()> {
+    if library_mode {
+        uniffi_bindgen::library_mode::generate_bindings(
+            library_file,
+            None,
+            &DartBindingGenerator {},
+            &LocalConfigSupplier(udl_file.to_string()),
+            None,
+            out_dir_override.unwrap(),
+            false,
+        )?;
+        Ok(())
+    } else {
+        uniffi_bindgen::generate_external_bindings(
+            &DartBindingGenerator {},
         udl_file,
         config_file_override,
         out_dir_override,
-        library_file,
+        Some(library_file),
         None,
         true,
-    )
+        )
+    }
 }
diff --git a/src/gen/objects.rs b/src/gen/objects.rs
index b490d3f..990cfaf 100644
--- a/src/gen/objects.rs
+++ b/src/gen/objects.rs
@@ -1,10 +1,11 @@
 use genco::prelude::*;
-use uniffi_bindgen::backend::{CodeType, Literal};
+use uniffi_bindgen::backend::Literal;
 use uniffi_bindgen::interface::{AsType, Method, Object};
 
 use crate::gen::oracle::{AsCodeType, DartCodeOracle};
 use crate::gen::render::AsRenderable;
 use crate::gen::render::{Renderable, TypeHelperRenderer};
+use crate::gen::CodeType;
 
 use super::stream::generate_stream;
 
@@ -64,41 +65,6 @@ pub fn generate_object(obj: &Object, type_helper: &dyn TypeHelperRenderer) -> da
     } else {
         quote!()
     };
-    
-    let constructor_definitions = obj.constructors().into_iter().map(|constructor| {
-        let ffi_func_name = constructor.ffi_func().name();
-        let constructor_name = constructor.name();
-
-        let dart_constructor_decl = if constructor_name == "new" {
-            quote!($cls_name)
-        } else {
-            quote!($cls_name.$(DartCodeOracle::fn_name(constructor_name)))
-        };
-
-        let dart_params = quote!($(for arg in constructor.arguments() =>
-            $(DartCodeOracle::dart_type_label(Some(&arg.as_type()))) $(DartCodeOracle::var_name(arg.name())),
-        ));
-
-        let ffi_call_args = quote!($(for arg in constructor.arguments() =>
-            $(DartCodeOracle::type_lower_fn(&arg.as_type(), quote!($(DartCodeOracle::var_name(arg.name()))))),) 
-        );
-        
-        // Ensure argument types are included
-        for arg in constructor.arguments() {
-            type_helper.include_once_check(&arg.as_codetype().canonical_name(), &arg.as_type());
-        }
-
-        quote! {
-            // Public constructor
-            $dart_constructor_decl($dart_params) : _ptr = rustCall((status) =>
-                $lib_instance.$ffi_func_name(
-                    $ffi_call_args status
-                )
-            ) {
-                 _$finalizer_cls_name.attach(this, _ptr, detach: this);
-            }
-        }
-    });
 
     quote! {
         final _$finalizer_cls_name = Finalizer<Pointer<Void>>((ptr) {
@@ -106,19 +72,14 @@ pub fn generate_object(obj: &Object, type_helper: &dyn TypeHelperRenderer) -> da
         });
 
         class $cls_name {
-            late final Pointer<Void> _ptr;
+            final Pointer<Void> _ptr;
 
-            // Private constructor for internal use / lift
-            $cls_name._(this._ptr) {
+            $(cls_name)._(this._ptr) {
                 _$finalizer_cls_name.attach(this, _ptr, detach: this);
             }
 
-            // Public constructors generated from UDL
-            $( for ctor_def in constructor_definitions => $ctor_def )
-
-            // Factory for lifting pointers
-            factory $cls_name.lift(Pointer<Void> ptr) {
-                return $cls_name._(ptr);
+            factory $(cls_name).lift(Pointer<Void> ptr) {
+                return $(cls_name)._(ptr);
             }
 
             Pointer<Void> uniffiClonePointer() {
@@ -168,26 +129,13 @@ pub fn generate_method(func: &Method, type_helper: &dyn TypeHelperRenderer) -> d
 
         )
     } else {
-        if ret == quote!(void) {
-            quote!(
-                $ret $(DartCodeOracle::fn_name(func.name()))($args) {
-                    return rustCall((status) {
-                        $(DartCodeOracle::find_lib_instance()).$(func.ffi_func().name())(
-                            uniffiClonePointer(),
-                            $(for arg in &func.arguments() => $(DartCodeOracle::type_lower_fn(&arg.as_type(), quote!($(DartCodeOracle::var_name(arg.name()))))),) status
-                        );
-                    });
-                }
-            )
-        } else {
-            quote!(
-                $ret $(DartCodeOracle::fn_name(func.name()))($args) {
-                    return rustCall((status) => $lifter($(DartCodeOracle::find_lib_instance()).$(func.ffi_func().name())(
-                        uniffiClonePointer(),
-                        $(for arg in &func.arguments() => $(DartCodeOracle::type_lower_fn(&arg.as_type(), quote!($(DartCodeOracle::var_name(arg.name()))))),) status
-                    )));
-                }
-            )
-      }
+        quote!(
+            $ret $(DartCodeOracle::fn_name(func.name()))($args) {
+                return rustCall((status) => $lifter($(DartCodeOracle::find_lib_instance()).$(func.ffi_func().name())(
+                    uniffiClonePointer(),
+                    $(for arg in &func.arguments() => $(DartCodeOracle::type_lower_fn(&arg.as_type(), quote!($(DartCodeOracle::var_name(arg.name()))))),) status
+                )));
+            }
+        )
     }
 }
diff --git a/src/gen/oracle.rs b/src/gen/oracle.rs
index 513e083..9777cff 100644
--- a/src/gen/oracle.rs
+++ b/src/gen/oracle.rs
@@ -1,8 +1,10 @@
 use genco::lang::dart;
 use genco::quote;
 use heck::{ToLowerCamelCase, ToUpperCamelCase};
-use uniffi_bindgen::backend::CodeType;
-use uniffi_bindgen::interface::{AsType, Callable, ExternalKind, FfiType, Type};
+use uniffi_bindgen::interface::ffi::ExternalFfiMetadata;
+
+use crate::gen::CodeType;
+use uniffi_bindgen::interface::{AsType, Callable, FfiType, Type};
 use uniffi_bindgen::ComponentInterface;
 
 use crate::gen::primitives;
@@ -34,9 +36,10 @@ impl DartCodeOracle {
     /// Get the idiomatic Dart rendering of a class name (for enums, records, errors, etc).
     pub fn class_name(nm: &str) -> String {
         let name = Self::sanitize_identifier(&nm.to_upper_camel_case());
-        // Replace "Error" with "Exception" in the name
-        let name = name.replace("Error", "Exception");
-        name
+        match name.strip_suffix("Error") {
+            None => name,
+            Some(stripped) => format!("{stripped}Exception"),
+        }
     }
 
     /// Get the idiomatic Dart rendering of a function name.
@@ -57,122 +60,96 @@ impl DartCodeOracle {
     /// Get the idiomatic Dart rendering of an FFI callback function name
     fn ffi_callback_name(nm: &str) -> String {
         format!(
-            "Pointer<NativeFunction<{}>>",
-            Self::callback_name(&nm.to_upper_camel_case())
+            "Pointer<NativeFunction<Uniffi{}>>",
+            nm.to_upper_camel_case()
         )
     }
 
-    /// Helper method to generate the callback name based on `Type`.
-    fn callback_name(name: &str) -> String {
-        format!("Uniffi{}", name.to_upper_camel_case())
-    }
-
-    /// Helper method to generate the struct name based on `Type`.
-    fn struct_name(name: &str) -> String {
-        format!("Uniffi{}", name.to_upper_camel_case())
-    }
-
-
-    /// Helper method to generate external Dart type labels.
-    fn external_type_label(name: &str) -> String {
-        format!("External{}", name.to_upper_camel_case())
-    }
-
-    /// Helper method to generate external native type labels.
-    fn external_native_type_label(name: &str) -> String {
-        format!("Pointer<{}>", Self::external_type_label(name))
-    }
-    /// Get the idiomatic Dart rendering of an exception name
-    // pub fn error_name(nm: &str) -> String {
-    //     let name = Self::class_name(nm);
-    //     match name.strip_suffix("Error") {
-    //         None => name,
-    //         Some(stripped) => format!("{stripped}Exception"),
-    //     }
-    // }
-
     pub fn find_lib_instance() -> dart::Tokens {
         quote!(_UniffiLib.instance)
     }
 
     // TODO: Replace instances of `generate_ffi_dart_type` with ffi_type_label
     pub fn ffi_dart_type_label(ffi_type: Option<&FfiType>) -> dart::Tokens {
-        if let Some(ret_type) = ffi_type {
-            match ret_type {
-                FfiType::Int8 => quote!(int),
-                FfiType::UInt8 => quote!(int),
-                FfiType::Int16 => quote!(int),
-                FfiType::UInt16 => quote!(int),
-                FfiType::Int32 => quote!(int),
-                FfiType::UInt32 => quote!(int),
-                FfiType::Int64 => quote!(int),
-                FfiType::UInt64 => quote!(int),
-                FfiType::Float32 => quote!(double),
-                FfiType::Float64 => quote!(double),
-                FfiType::RustArcPtr(_) => quote!(Pointer<Void>),
-                FfiType::RustBuffer(_t) => quote!(RustBuffer),
-                FfiType::ForeignBytes => quote!(ForeignBytes),
-                FfiType::Handle => quote!(Pointer<Void>),
-                FfiType::Callback(name) => quote!($(Self::ffi_callback_name(name))),
-                FfiType::Reference(inner) => quote!($(Self::ffi_type_label_by_reference(inner))),
-                _ => panic!("Unimplemented FfiType: {:?}", ret_type), // Fallback implementation
-            }
-        } else {
-            quote!(void)
+        let Some(ret_type) = ffi_type else {
+            return quote!(void);
+        };
+        match ret_type {
+            FfiType::UInt8
+            | FfiType::UInt16
+            | FfiType::UInt32
+            | FfiType::UInt64
+            | FfiType::Int8
+            | FfiType::Int16
+            | FfiType::Int32
+            | FfiType::Handle
+            | FfiType::Int64 => quote!(int),
+            FfiType::Float32 | FfiType::Float64 => quote!(double),
+            FfiType::RustBuffer(ref inner) => match inner {
+                Some(ExternalFfiMetadata { name, .. }) => quote!($(Self::ffi_struct_name(name)) ),
+                _ => quote!(RustBuffer),
+            },
+            FfiType::ForeignBytes => quote!(ForeignBytes),
+            FfiType::RustArcPtr(_) => quote!(Pointer<Void>),
+            FfiType::Callback(name) => quote!($(Self::ffi_callback_name(name))),
+            FfiType::Reference(inner) => quote!($(Self::ffi_type_label_by_reference(inner))),
+            _ => todo!("FfiType::{:?}", ret_type),
         }
     }
 
     pub fn ffi_native_type_label(ffi_ret_type: Option<&FfiType>) -> dart::Tokens {
-        if let Some(ret_type) = ffi_ret_type {
-            match ret_type {
-                FfiType::Int8 => quote!(Int8),
-                FfiType::UInt8 => quote!(Uint8),
-                FfiType::Int16 => quote!(Int16),
-                FfiType::UInt16 => quote!(Uint16),
-                FfiType::Int32 => quote!(Int32),
-                FfiType::UInt32 => quote!(Uint32),
-                FfiType::Int64 => quote!(Int64),
-                FfiType::UInt64 => quote!(Uint64),
-                FfiType::Float32 => quote!(Float),
-                FfiType::Float64 => quote!(Double),
-                FfiType::RustArcPtr(_) => quote!(Pointer<Void>),
-                FfiType::RustBuffer(_t) => quote!(RustBuffer),
-                FfiType::ForeignBytes => quote!(ForeignBytes),
-                FfiType::Handle => quote!(Pointer<Void>),
-                FfiType::Callback(name) => quote!($(Self::ffi_callback_name(name))),
-                FfiType::Reference(inner) => quote!($(Self::ffi_type_label_by_reference(inner))),
-                _ => panic!("Unimplemented FfiType: {:?}", ret_type), // Fallback implementation
-            }
-        } else {
-            quote!(void)
+        let Some(ret_type) = ffi_ret_type else {
+            return quote!(Void);
+        };
+        match ret_type {
+            FfiType::UInt8 => quote!(Uint8),
+            FfiType::UInt16 => quote!(Uint16),
+            FfiType::UInt32 => quote!(Uint32),
+            FfiType::UInt64 => quote!(Uint64),
+            FfiType::Int8 => quote!(Int8),
+            FfiType::Int16 => quote!(Int16),
+            FfiType::Int32 => quote!(Int32),
+            FfiType::Int64 => quote!(Int64),
+            FfiType::Float32 => quote!(Float),
+            FfiType::Float64 => quote!(Double),
+            FfiType::Handle => quote!(Uint64),
+            FfiType::RustBuffer(ref inner) => match inner {
+                Some(ExternalFfiMetadata { name, .. }) => quote!($(Self::ffi_struct_name(name)) ),
+                _ => quote!(RustBuffer),
+            },
+            FfiType::ForeignBytes => quote!(ForeignBytes),
+            FfiType::RustArcPtr(_) => quote!(Pointer<Void>),
+            FfiType::Callback(name) => quote!($(Self::ffi_callback_name(name))),
+            FfiType::Reference(inner) => quote!($(Self::ffi_type_label_by_reference(inner))),
+            _ => todo!("FfiType::{:?}", ret_type),
         }
     }
 
     fn ffi_type_label_by_reference(ffi_type: &FfiType) -> dart::Tokens {
         match ffi_type {
-            FfiType::Int8 => quote!(Int8),
             FfiType::UInt8 => quote!(Uint8),
-            FfiType::Int16 => quote!(Int16),
             FfiType::UInt16 => quote!(Uint16),
-            FfiType::Int32 => quote!(Int32),
             FfiType::UInt32 => quote!(Uint32),
-            FfiType::Int64 => quote!(Int64),
             FfiType::UInt64 => quote!(Uint64),
+            FfiType::Int8 => quote!(Int8),
+            FfiType::Int16 => quote!(Int16),
+            FfiType::Int32 => quote!(Int32),
+            FfiType::Int64 => quote!(Int64),
             FfiType::Float32 => quote!(Float),
             FfiType::Float64 => quote!(Double),
-            FfiType::RustArcPtr(_) => quote!(Pointer<Void>),
+            FfiType::Handle => quote!(Uint64),
             FfiType::RustBuffer(_) => quote!(RustBuffer),
-            FfiType::Callback(name) => quote!(Pointer<$(Self::ffi_callback_name(name))>),
-            FfiType::Struct(name) => quote!(Pointer<$(Self::ffi_struct_name(name))>),
-            _ => quote!(Pointer<Void>), // Fallback implementation
+            FfiType::ForeignBytes => quote!(ForeignBytes),
+            FfiType::RustArcPtr(_) => quote!(Pointer<Void>),
+            FfiType::Callback(name) => quote!($(Self::ffi_callback_name(name))),
+            FfiType::Struct(name) => quote!($(Self::ffi_struct_name(name))),
+            _ => todo!("FfiType::{:?}", ffi_type),
         }
     }
 
     pub fn ffi_struct_name(name: &str) -> dart::Tokens {
-       quote!($(format!("Uniffi{}", name.to_upper_camel_case())))
+        quote!($(format!("Uniffi{}", name.to_upper_camel_case())))
     }
-
-    
     // pub fn convert_from_rust_buffer(ty: &Type, inner: dart::Tokens) -> dart::Tokens {
     //     match ty {
     //         Type::Object { .. } => inner,
@@ -191,32 +168,31 @@ impl DartCodeOracle {
     //     }
     // }
 
-    pub fn type_lift_fn(ty: &Type, inner: dart::Tokens) -> dart::Tokens {
-        match ty {
-            Type::UInt8
-            | Type::Int8
-            | Type::Int16
-            | Type::UInt16
-            | Type::Int32
-            | Type::Int64
-            | Type::UInt32
-            | Type::UInt64
-            | Type::Float32
-            | Type::Float64 => inner,
-            Type::Boolean
-            | Type::Duration
-            | Type::String
-            | Type::Object { .. }
-            | Type::Enum { .. }
-            | Type::Record { .. }
-            | Type::Optional { .. } => {
-                quote!($(ty.as_codetype().ffi_converter_name()).lift($inner))
-            }
-            _ => quote!($(ty.as_codetype().ffi_converter_name()).lift($inner)), // Fallback implementation
-        }
-    }
+    // pub fn type_lift_fn(ty: &Type, inner: dart::Tokens) -> dart::Tokens {
+    //     match ty {
+    //         Type::Int8
+    //         | Type::UInt8
+    //         | Type::Int16
+    //         | Type::UInt16
+    //         | Type::Int32
+    //         | Type::Int64
+    //         | Type::UInt32
+    //         | Type::UInt64
+    //         | Type::Float32
+    //         | Type::Float64 => inner,
+    //         Type::Boolean
+    //         | Type::Duration
+    //         | Type::String
+    //         | Type::Object { .. }
+    //         | Type::Enum { .. }
+    //         | Type::Record { .. }
+    //         | Type::Optional { .. } => {
+    //             quote!($(ty.as_codetype().ffi_converter_name()).lift($inner))
+    //         }
+    //         _ => todo!("lift Type::{:?}", ty),
+    //     }
+    // }
 
-    
     pub fn type_lower_fn(ty: &Type, inner: dart::Tokens) -> dart::Tokens {
         match ty {
             Type::UInt32
@@ -235,10 +211,12 @@ impl DartCodeOracle {
             | Type::Object { .. }
             | Type::Enum { .. }
             | Type::Optional { .. }
-            | Type::Record { .. } => {
+            | Type::Record { .. }
+            | Type::Sequence { .. }
+            | Type::CallbackInterface { .. } => {
                 quote!($(ty.as_codetype().ffi_converter_name()).lower($inner))
             }
-            _ => quote!($(ty.as_codetype().ffi_converter_name()).lower($inner)), // Fallback implementation
+            _ => todo!("lower Type::{:?}", ty),
         }
     }
 
@@ -251,13 +229,16 @@ impl DartCodeOracle {
         let ffi_func = callable.ffi_rust_future_complete(ci);
         let call = quote!($(Self::find_lib_instance()).$ffi_func);
         match callable.return_type() {
-            Some(Type::External {
-                kind: ExternalKind::DataClass,
-                name: _,
-                ..
-            }) => {
+            Some(Type::External { .. }) => {
+                // Some(return_type) if ci.is_external(&return_type) => {
+                //     let ffi_type = FfiType::from(return_type);
+                //     match ffi_type {
+                // FfiType::RustBuffer(Some(ExternalFfiMetadata { .. })) => {
                 todo!("Need to convert the RustBuffer from our package to the RustBuffer of the external package")
             }
+            // _ => call,
+            // }
+            // }
             _ => call,
         }
     }
@@ -266,306 +247,6 @@ impl DartCodeOracle {
         let ffi_func = callable.ffi_rust_future_free(ci);
         quote!($(Self::find_lib_instance()).$ffi_func)
     }
-
-    /// Get the idiomatic Dart rendering of a class name based on `Type`.
-    pub fn dart_type_label(type_: Option<&Type>) -> dart::Tokens {
-        if let Some(ret_type) = type_ {
-            match ret_type {
-                Type::UInt8
-                | Type::UInt16
-                | Type::UInt32
-                | Type::UInt64
-                | Type::Int8
-                | Type::Int16
-                | Type::Int32
-                | Type::Int64 => quote!(int),
-                Type::Float32 | Type::Float64 => quote!(double),
-                Type::Boolean => quote!(bool),
-                Type::String => quote!(String),
-                Type::Timestamp => quote!(DateTime),
-                Type::Duration => quote!(Duration),
-                // Reference types
-                Type::Object { name, .. } => {
-                    let class_name = &DartCodeOracle::class_name(name);
-                    quote!($class_name)
-                }
-                Type::Optional { inner_type } => {
-                    let inner = DartCodeOracle::dart_type_label(Some(inner_type));
-                    quote!($inner?)
-                }
-                Type::Sequence { inner_type } => {
-                    let inner = DartCodeOracle::dart_type_label(Some(inner_type));
-                    quote!(List<$inner>)
-                }
-                Type::Map { key_type, value_type, .. } => {
-                    let key = DartCodeOracle::dart_type_label(Some(key_type));
-                    let value = DartCodeOracle::dart_type_label(Some(value_type));
-                    quote!(Map<$key, $value>)
-                }
-                Type::External { name, .. } => {
-                    let external_name = &DartCodeOracle::external_type_label(name);
-                    quote!($external_name)
-                }
-                Type::Enum { name, .. } => {
-                    let enum_name = &DartCodeOracle::class_name(name);
-                    quote!($enum_name)
-                }
-                Type::Record { name, .. } => {
-                    let rec_name = &DartCodeOracle::class_name(name);
-                    quote!($rec_name)
-                }
-                Type::Custom { name, .. } => {
-                    let type_name = &DartCodeOracle::class_name(name);
-                    quote!($type_name)
-                }
-                _ => quote!(dynamic),
-            }
-        } else {
-            quote!(void)
-        }
-    }
-
-    /// Get the native Dart FFI type rendering based on `Type`.
-    pub fn native_type_label(native_ret_type: Option<&Type>) -> dart::Tokens {
-        if let Some(ret_type) = native_ret_type {
-            match ret_type {
-                Type::UInt8 => quote!(Uint8),
-                Type::UInt16 => quote!(Uint16),
-                Type::UInt32 => quote!(Uint32),
-                Type::UInt64 => quote!(Uint64),
-                Type::Int8 => quote!(Int8),
-                Type::Int16 => quote!(Int16),
-                Type::Int32 => quote!(Int32),
-                Type::Int64 => quote!(Int64),
-                Type::Float32 => quote!(Float),
-                Type::Float64 => quote!(Double),
-                Type::Boolean => quote!(Int8),
-                Type::String => quote!(RustBuffer),
-                Type::Timestamp => quote!(Int64),
-                Type::Duration => quote!(Int64),
-                Type::Optional { inner_type } => match **inner_type {
-                    Type::String => quote!(RustBuffer),
-                    _ => quote!(RustBuffer),
-                },
-                Type::Sequence { .. } => quote!(RustBuffer),
-                Type::Map { .. } => quote!(RustBuffer),
-                Type::Object { .. } => quote!(Pointer<Void>),
-                Type::Enum { .. } => quote!(Int32),
-                Type::Record { .. } => quote!(RustBuffer),
-                Type::External { name, .. } => {
-                    let external_name = &DartCodeOracle::external_native_type_label(name);
-                    quote!($external_name)
-                },
-                Type::Custom { name, .. } => {
-                    let class_name = &DartCodeOracle::class_name(name);
-                    quote!($class_name)
-                },
-                _ => quote!(Pointer<Void>),
-            }
-        } else {
-            quote!(Void)
-        }
-    }
-
-    /// Get the native Dart FFI type rendering based on `Type`.
-    pub fn native_dart_type_label(native_ret_type: Option<&Type>) -> dart::Tokens {
-        if let Some(ret_type) = native_ret_type {
-            match ret_type {
-                Type::UInt8
-                | Type::UInt16
-                | Type::UInt32
-                | Type::UInt64
-                | Type::Int8
-                | Type::Int16
-                | Type::Int32
-                | Type::Int64 => quote!(int), // Adjust based on actual FFI size
-                Type::Float32 => quote!(double),
-                Type::Float64 => quote!(double),
-                Type::Boolean => quote!(int),
-                Type::String => quote!(RustBuffer),
-                Type::Timestamp => quote!(int),
-                Type::Duration => quote!(int),
-                Type::Optional { inner_type } => match **inner_type {
-                    Type::String => quote!(RustBuffer),
-                    _ => quote!(RustBuffer),
-                },
-                Type::Sequence { .. } => quote!(RustBuffer),
-                Type::Map { .. } => quote!(RustBuffer),
-                Type::Object { .. } => quote!(Pointer<Void>),
-                Type::Enum { .. } => quote!(int),
-                Type::Record { .. } => quote!(RustBuffer),
-                Type::External { name, .. } => {
-                    let external_name = &DartCodeOracle::external_type_label(name);
-                    quote!($external_name)
-                },
-                Type::Custom { name, .. } => {
-                    let type_name = &DartCodeOracle::class_name(name);
-                    quote!($type_name)
-                },
-                _ => quote!(dynamic),
-            }
-        } else {
-            quote!(void)
-        }
-    }
-
-    // Method to get the appropriate callback parameter type
-    pub fn callback_param_type(arg_type: &Type, arg_name: &str) -> dart::Tokens {
-        match arg_type {
-            Type::Boolean => quote!(int $arg_name),
-            Type::String => quote!(RustBuffer $(arg_name)Buffer),
-            Type::Optional { inner_type } => {
-                if let Type::String = **inner_type {
-                    quote!(RustBuffer $(arg_name)Buffer)
-                } else {
-                    //let type_label = DartCodeOracle::dart_type_label(Some(arg_type));
-                    quote!(RustBuffer $arg_name)
-                }
-            },
-            Type::Sequence { inner_type } => {
-                if let Type::Int32 = **inner_type {
-                    quote!(RustBuffer $(arg_name)Buffer)
-                } else {
-                    //let type_label = DartCodeOracle::dart_type_label(Some(arg_type));
-                    quote!(RustBuffer $arg_name)
-                }
-            },
-            _ => {
-                let type_label = DartCodeOracle::dart_type_label(Some(arg_type));
-                quote!($type_label $arg_name)
-            }
-        }
-    }
-
-    // Method to generate code for handling callback return values
-    pub fn callback_return_handling(ret_type: &Type, method_name: &str, args: Vec<dart::Tokens>) -> dart::Tokens {
-        match ret_type {
-            Type::Boolean => {
-                // For boolean return values
-                quote!(
-                    final result = obj.$method_name($(for arg in &args => $arg,));
-                    outReturn.value = result ? 1 : 0;
-                )
-            },
-            Type::Optional { inner_type } => {
-                // For optional return values
-                if let Type::String = **inner_type {
-                    quote!(
-                        final result = obj.$method_name($(for arg in &args => $arg,));
-                        if (result == null) {
-                            outReturn.ref = toRustBuffer(Uint8List.fromList([0]));
-                        } else {
-                            final lowered = FfiConverterOptionalString.lower(result);
-                            outReturn.ref = toRustBuffer(lowered.asUint8List());
-                        }
-                    )
-                } else {
-                    let lowered = ret_type.as_codetype().ffi_converter_name();
-                    quote!(
-                        final result = obj.$method_name($(for arg in &args => $arg,));
-                        if (result == null) {
-                            outReturn.ref = toRustBuffer(Uint8List.fromList([0]));
-                        } else {
-                            final lowered = $lowered.lower(result);
-                            final buffer = Uint8List(1 + lowered.length);
-                            buffer[0] = 1;
-                            buffer.setAll(1, lowered.asUint8List());
-                            outReturn.ref = toRustBuffer(buffer);
-                        }
-                    )
-                }
-            },
-            Type::String => {
-                // For string return values
-                quote!(
-                    final result = obj.$method_name($(for arg in &args => $arg,));
-                    outReturn.ref = FfiConverterString.lower(result);
-                    status.code = CALL_SUCCESS;
-                )
-            },
-            Type::Sequence { inner_type } => {
-                if let Type::Int32 = **inner_type {
-                    // For int32 sequence return values
-                    quote!(
-                        final result = obj.$method_name($(for arg in &args => $arg,));
-                        outReturn.ref = FfiConverterSequenceInt32.lower(result);
-                    )
-                } else {
-                    // For other sequence types
-                    let lowered = ret_type.as_codetype().ffi_converter_name();
-                    quote!(
-                        final result = obj.$method_name($(for arg in &args => $arg,));
-                        outReturn.ref = $lowered.lower(result);
-                    )
-                }
-            },
-            _ => {
-                // For other return types
-                let lowered = ret_type.as_codetype().ffi_converter_name();
-                quote!(
-                    final result = obj.$method_name($(for arg in &args => $arg,));
-                    outReturn.ref = $lowered.lower(result);
-                )
-            }
-        }
-    }
-
-    // Method to get the appropriate return type for callback functions
-    pub fn callback_out_return_type(ret_type: Option<&Type>) -> dart::Tokens {
-        if let Some(ret) = ret_type {
-            match ret {
-                Type::Boolean => quote!(Pointer<Int8>),
-                _ => quote!(Pointer<RustBuffer>)
-            }
-        } else {
-            quote!(Pointer<Void>)
-        }
-    }
-
-    // Method to handle void return values in callbacks
-    pub fn callback_void_handling(method_name: &str, args: Vec<dart::Tokens>) -> dart::Tokens {
-        quote!(
-            obj.$method_name($(for arg in &args => $arg,));
-            status.code = CALL_SUCCESS;
-        )
-    }
-
-    // Method to get the appropriate lift expression for callback arguments with indexed variable names
-    pub fn callback_arg_lift_indexed(arg_type: &Type, arg_name: &str, arg_idx: usize) -> dart::Tokens {
-        // Use index-based variable names to avoid conflicts
-        if let Type::Boolean = arg_type {
-            quote!(final bool_arg$(arg_idx) = $arg_name == 1;)
-        } else if let Type::String = arg_type {
-            quote!(final arg$(arg_idx) = FfiConverterString.lift($(arg_name)Buffer);)
-        } else if let Type::Optional { inner_type } = arg_type {
-            if let Type::String = **inner_type {
-                quote!(final arg$(arg_idx) = FfiConverterOptionalString.lift($(arg_name)Buffer);)
-            } else {
-                let converter = arg_type.as_codetype().ffi_converter_name();
-                quote!(final arg$(arg_idx) = $converter.lift($arg_name);)
-            }
-        } else if let Type::Sequence { inner_type } = arg_type {
-            if let Type::Int32 = **inner_type {
-                quote!(final arg$(arg_idx) = FfiConverterSequenceInt32.lift($(arg_name)Buffer);)
-            } else {
-                let converter = arg_type.as_codetype().ffi_converter_name();
-                quote!(final arg$(arg_idx) = $converter.lift($arg_name);)
-            }
-        } else {
-            let converter = arg_type.as_codetype().ffi_converter_name();
-            quote!(final arg$(arg_idx) = $converter.lift($arg_name);)
-        }
-    }
-
-    // Method to get argument name for a callback method based on type and index
-    pub fn callback_arg_name(arg_type: &Type, arg_idx: usize) -> dart::Tokens {
-        if let Type::Boolean = arg_type {
-            quote!(bool_arg$(arg_idx))
-        } else {
-            quote!(arg$(arg_idx))
-        }
-    }
-
 }
 
 // https://dart.dev/guides/language/language-tour#keywords
@@ -665,8 +346,10 @@ impl<T: AsType> AsCodeType for T {
                 *inner_type,
             )),
             Type::Enum { name, .. } => Box::new(enums::EnumCodeType::new(name)),
-            Type::Record {name, .. } => Box::new(records::RecordCodeType::new(name)),
-            Type::CallbackInterface { name, .. } => Box::new(callback_interface::CallbackInterfaceCodeType::new(name, self.as_type())),
+            Type::Record { name, .. } => Box::new(records::RecordCodeType::new(name)),
+            Type::CallbackInterface { name, .. } => {
+                Box::new(callback_interface::CallbackInterfaceCodeType::new(name))
+            }
             _ => todo!("As Type for Type::{:?}", self.as_type()),
         }
     }
diff --git a/src/gen/primitives/macros.rs b/src/gen/primitives/macros.rs
index a58ef6e..47ff55b 100644
--- a/src/gen/primitives/macros.rs
+++ b/src/gen/primitives/macros.rs
@@ -4,7 +4,7 @@ macro_rules! impl_code_type_for_primitive {
             #[derive(Debug)]
             pub struct $T;
 
-            impl uniffi_bindgen::backend::CodeType for $T  {
+            impl crate::gen::CodeType for $T  {
                 fn type_label(&self,) -> String {
                     $class_name.into()
                 }
@@ -20,23 +20,6 @@ macro_rules! impl_code_type_for_primitive {
                 fn ffi_converter_name(&self) -> String {
                     format!("FfiConverter{}", self.canonical_name())
                 }
-
-                // The following must create an instance of the converter object
-                fn lower(&self) -> String {
-                    format!("{}.lower", self.ffi_converter_name())
-                }
-
-                fn write(&self) -> String {
-                    format!("{}.write", self.ffi_converter_name())
-                }
-
-                fn lift(&self) -> String {
-                    format!("{}.lift", self.ffi_converter_name())
-                }
-
-                fn read(&self) -> String {
-                    format!("{}.read", self.ffi_converter_name())
-                }
             }
         }
     };
@@ -46,7 +29,7 @@ macro_rules! impl_renderable_for_primitive {
     ($T:ty, $class_name:literal, $canonical_name:literal, $allocation_size:literal) => {
         impl Renderable for $T {
             fn render_type_helper(&self, _type_helper: &dyn TypeHelperRenderer) -> dart::Tokens {
-                use uniffi_bindgen::backend::CodeType;
+                use crate::gen::code_type::CodeType;
                 let endian = (if $canonical_name.contains("Float") {
                     ", Endian.little"
                 } else {
diff --git a/src/gen/primitives/string.rs b/src/gen/primitives/string.rs
index 2ae3c6a..a5c86c9 100644
--- a/src/gen/primitives/string.rs
+++ b/src/gen/primitives/string.rs
@@ -2,9 +2,10 @@ use crate::gen::{
     quote,
     render::{Renderable, TypeHelperRenderer},
 };
+use crate::r#gen::CodeType;
 
 use genco::lang::dart;
-use uniffi_bindgen::backend::CodeType;
+// use uniffi_bindgen::backend::CodeType;
 
 #[derive(Debug)]
 pub struct StringCodeType;
diff --git a/src/gen/records.rs b/src/gen/records.rs
index cd8e05d..5c5b6a3 100644
--- a/src/gen/records.rs
+++ b/src/gen/records.rs
@@ -1,8 +1,9 @@
 use super::oracle::{AsCodeType, DartCodeOracle};
 use super::render::{Renderable, TypeHelperRenderer};
 use super::types::generate_type;
+use super::CodeType;
 use genco::prelude::*;
-use uniffi_bindgen::backend::{CodeType, Literal};
+// use uniffi_bindgen::backend::Literal;
 use uniffi_bindgen::interface::{AsType, Record};
 
 #[derive(Debug)]
@@ -27,10 +28,6 @@ impl CodeType for RecordCodeType {
     fn canonical_name(&self) -> String {
         self.id.to_string()
     }
-
-    fn literal(&self, _literal: &Literal) -> String {
-        todo!("literal not implemented for RecordCodeType");
-    }
 }
 
 impl Renderable for RecordCodeType {
diff --git a/src/gen/render/mod.rs b/src/gen/render/mod.rs
index 024af4f..236838f 100644
--- a/src/gen/render/mod.rs
+++ b/src/gen/render/mod.rs
@@ -90,8 +90,10 @@ impl<T: AsType> AsRenderable for T {
                 *inner_type,
             )),
             Type::Enum { name, .. } => Box::new(enums::EnumCodeType::new(name)),
-            Type::Record {name, .. } => Box::new(records::RecordCodeType::new(name)),
-            Type::CallbackInterface { name, .. } => Box::new(callback_interface::CallbackInterfaceCodeType::new(name, self.as_type())),
+            Type::Record { name, .. } => Box::new(records::RecordCodeType::new(name)),
+            Type::CallbackInterface { name, .. } => {
+                Box::new(callback_interface::CallbackInterfaceCodeType::new(name))
+            }
             _ => todo!("Renderable for Type::{:?}", self.as_type()),
         }
     }
diff --git a/src/gen/stream/mod.rs b/src/gen/stream/mod.rs
index d5d2b7e..65a81d6 100644
--- a/src/gen/stream/mod.rs
+++ b/src/gen/stream/mod.rs
@@ -13,17 +13,12 @@ pub fn generate_stream(obj: &Object, _type_helper: &dyn TypeHelperRenderer) -> d
     quote! {
         $fn_name() async* {
             final $obj_var_name = $create_obj_fn_name();
-            try {
-                while (true) {
-                    final value = await $obj_var_name.next();
-                    if (value == null) {
-                        break;
-                    }
-                    yield value;
+            while (true) {
+                final value = await $obj_var_name.next();
+                if (value == null) {
+                    break;
                 }
-            } catch (e) {
-                // Handle exceptions if necessary
-                rethrow;
+                yield value;
             }
             // No need to call drop(), Finalizer will handle it
         }
diff --git a/src/gen/types.rs b/src/gen/types.rs
index f562f59..ade7615 100644
--- a/src/gen/types.rs
+++ b/src/gen/types.rs
@@ -1,11 +1,9 @@
 use std::{cell::RefCell, collections::HashMap};
 
 use genco::prelude::*;
-use uniffi_bindgen::interface::AsType;
 use uniffi_bindgen::{interface::Type, ComponentInterface};
-use uniffi_bindgen::backend::CodeType;
 
-use super::render::{AsRenderable, Renderer, TypeHelperRenderer, Renderable};
+use super::render::{AsRenderable, Renderer, TypeHelperRenderer};
 use super::{enums, functions, objects, oracle::AsCodeType, records};
 use crate::gen::DartCodeOracle;
 
@@ -84,18 +82,12 @@ impl Renderer<(FunctionDefinition, dart::Tokens)> for TypeHelpersRenderer<'_> {
             $(for fun in self.ci.function_definitions() => $(functions::generate_function(fun, self)))
         );
 
-        let mut callback_code = quote!();
-        // Process all callback interfaces to ensure they're included
-        for callback in self.ci.callback_interface_definitions() {
-            let callback_name = callback.name().to_string();
-            let callback_codetype = super::callback_interface::CallbackInterfaceCodeType::new(callback_name, callback.as_type());
-            // Force the callback interface to be processed, due to the way the code is generated we need to ensure it's processed, when a callback is used in a function signature
-            // TODO: This is a hack to ensure the callback interface is processed, we need to test to ensure there's no chance of duplicates
-            callback_code.append(callback_codetype.render_type_helper(self));
-        }
-
         // Let's include the string converter
         self.include_once_check(&Type::String.as_codetype().canonical_name(), &Type::String);
+        self.include_once_check(
+            &Type::Boolean.as_codetype().canonical_name(),
+            &Type::Boolean,
+        );
         let helpers_definitions = quote! {
             $(for (_, ty) in self.get_include_names().iter() => $(ty.as_renderable().render_type_helper(self)) )
         };
@@ -164,7 +156,7 @@ impl Renderer<(FunctionDefinition, dart::Tokens)> for TypeHelpersRenderer<'_> {
             const int CALL_ERROR = 1;
             const int CALL_UNEXPECTED_ERROR = 2;
 
-            final class RustCallStatus extends Struct {
+            class RustCallStatus extends Struct {
                 @Int8()
                 external int code;
 
@@ -173,20 +165,20 @@ impl Renderer<(FunctionDefinition, dart::Tokens)> for TypeHelpersRenderer<'_> {
                 //Pointer<RustCallStatus> asPointer() => Pointer<RustCallStatus>.fromAddress(address);
             }
 
-            void checkCallStatus(UniffiRustCallStatusErrorHandler errorHandler, Pointer<RustCallStatus> status) {
+            void checkCallStatus(UniffiRustCallStatusErrorHandler errorHandler, RustCallStatus status) {
 
-                if (status.ref.code == CALL_SUCCESS) {
+                if (status.code == CALL_SUCCESS) {
                 return;
-                } else if (status.ref.code == CALL_ERROR) {
-                throw errorHandler.lift(status.ref.errorBuf);
-                } else if (status.ref.code == CALL_UNEXPECTED_ERROR) {
-                if (status.ref.errorBuf.len > 0) {
-                    throw UniffiInternalError.panicked(FfiConverterString.lift(status.ref.errorBuf));
+                } else if (status.code == CALL_ERROR) {
+                throw errorHandler.lift(status.errorBuf);
+                } else if (status.code == CALL_UNEXPECTED_ERROR) {
+                if (status.errorBuf.len > 0) {
+                    throw UniffiInternalError.panicked(FfiConverterString.lift(status.errorBuf));
                 } else {
                     throw UniffiInternalError.panicked("Rust panic");
                 }
                 } else {
-                throw UniffiInternalError.panicked("Unexpected RustCallStatus code: ${status.ref.code}");
+                throw UniffiInternalError.panicked("Unexpected RustCallStatus code: ${status.code}");
                 }
             }
 
@@ -211,7 +203,7 @@ impl Renderer<(FunctionDefinition, dart::Tokens)> for TypeHelpersRenderer<'_> {
                 Exception lift(RustBuffer errorBuf);
             }
 
-            final class RustBuffer extends Struct {
+            class RustBuffer extends Struct {
                 @Uint64()
                 external int capacity;
 
@@ -266,7 +258,7 @@ impl Renderer<(FunctionDefinition, dart::Tokens)> for TypeHelpersRenderer<'_> {
                 return RustBuffer.fromBytes(bytes.ref);
             }
 
-            final class ForeignBytes extends Struct {
+            class ForeignBytes extends Struct {
                 @Int32()
                 external int len;
                 external Pointer<Uint8> data;
@@ -339,10 +331,10 @@ impl Renderer<(FunctionDefinition, dart::Tokens)> for TypeHelpersRenderer<'_> {
             typedef UniffiRustFutureContinuationCallback = Void Function(Uint64, Int8);
 
             Future<T> uniffiRustCallAsync<T, F>(
-                Pointer<Void> Function() rustFutureFunc,
-                void Function(Pointer<Void>, Pointer<NativeFunction<UniffiRustFutureContinuationCallback>>, Pointer<Void>) pollFunc,
-                F Function(Pointer<Void>, Pointer<RustCallStatus>) completeFunc,
-                void Function(Pointer<Void>) freeFunc,
+                int Function() rustFutureFunc,
+                void Function(int, Pointer<NativeFunction<UniffiRustFutureContinuationCallback>>, int) pollFunc,
+                F Function(int, Pointer<RustCallStatus>) completeFunc,
+                void Function(int) freeFunc,
                 T Function(F) liftFunc, [
                 UniffiRustCallStatusErrorHandler? errorHandler,
             ]) async {
@@ -355,7 +347,7 @@ impl Renderer<(FunctionDefinition, dart::Tokens)> for TypeHelpersRenderer<'_> {
                     pollFunc(
                         rustFuture,
                         callback.nativeFunction,
-                        Pointer<Void>.fromAddress(0),
+                        0,
                     );
                 }
                 void onResponse(int _idx, int pollResult) {
@@ -387,33 +379,6 @@ impl Renderer<(FunctionDefinition, dart::Tokens)> for TypeHelpersRenderer<'_> {
                 }
             }
 
-            class UniffiHandleMap<T> {
-                final Map<int, T> _map = {};
-                int _counter = 0;
-            
-                int insert(T obj) {
-                final handle = _counter++;
-                _map[handle] = obj;
-                return handle;
-                }
-            
-                T get(int handle) {
-                final obj = _map[handle];
-                if (obj == null) {
-                    throw UniffiInternalError(
-                        UniffiInternalError.unexpectedStaleHandle, "Handle not found");
-                }
-                return obj;
-                }
-            
-                void remove(int handle) {
-                if (_map.remove(handle) == null) {
-                    throw UniffiInternalError(
-                        UniffiInternalError.unexpectedStaleHandle, "Handle not found");
-                }
-                }
-            }
-
         };
 
         (types_helper_code, function_definitions)
diff --git a/src/testing.rs b/src/testing.rs
index 354b7b4..a8958ed 100644
--- a/src/testing.rs
+++ b/src/testing.rs
@@ -39,7 +39,7 @@ pub fn run_test(fixture: &str, udl_path: &str, config_path: Option<&str>) -> Res
     version: 1.0.0
 
     environment:
-      sdk: '>=3.5.0'
+      sdk: '>=2.19.6 <3.0.0'
     dev_dependencies:
       test: ^1.24.3
     dependencies:
